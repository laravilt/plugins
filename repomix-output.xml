This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: **/*.log, tmp/, .js, .html, .blade.php, .css, public/, vendor/, node_modules, venv/, logs/, electorn-sentinerl/
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.github/
  ISSUE_TEMPLATE/
    bug.yml
    config.yml
  workflows/
    dependabot-auto-merge.yml
    fix-php-code-styling.yml
    tests.yml
  CONTRIBUTING.md
  dependabot.yml
  FUNDING.yml
  SECURITY.md
config/
  laravilt-plugins.php
docs/
  index.md
  mcp-server.md
src/
  Commands/
    Concerns/
      HandlesFiles.php
      ManagesStubs.php
      RunsCommands.php
    InstallMcpServerCommand.php
    MakeComponentCommand.php
    MakePluginCommand.php
  Concerns/
    HasAssets.php
    HasCommands.php
    HasComponents.php
    HasMigrations.php
    HasTranslations.php
    HasViews.php
  Contracts/
    Plugin.php
    PluginFeatureInterface.php
    PluginManager.php
  Facades/
    LaraviltPlugins.php
  Features/
    AbstractFeature.php
    ArtsFeature.php
    ComposerJsonFeature.php
    ConfigFeature.php
    CssFeature.php
    DocumentationFeature.php
    GitHubFeature.php
    GitignoreFeature.php
    InstallCommandFeature.php
    JsFeature.php
    LanguageFeature.php
    MigrationsFeature.php
    PintFeature.php
    PluginClassFeature.php
    ReadmeFeature.php
    RoutesFeature.php
    ServiceProviderFeature.php
    TestbenchFeature.php
    TestingFeature.php
    ViewsFeature.php
  Mcp/
    Tools/
      GenerateComponentTool.php
      GeneratePluginTool.php
      ListComponentTypesTool.php
      ListPluginsTool.php
      PluginInfoTool.php
      PluginStructureTool.php
      SearchDocsTool.php
    LaraviltPluginsServer.php
  Services/
    Generation/
      StubProcessor.php
    PluginFeatureFactory.php
    PluginGenerator.php
  Stubs/
    css/
      app.stub
    github/
      ISSUE_TEMPLATE/
        bug_report.md.stub
        bug.yml.stub
        config.yml.stub
        feature_request.md.stub
      workflows/
        dependabot-auto-merge.yml.stub
        fix-php-code-styling.yml.stub
        tests.yml.stub
      CONTRIBUTING.md.stub
      dependabot.yml.stub
      FUNDING.yml.stub
      SECURITY.md.stub
    js/
      app.stub
    routes/
      api.stub
      web.stub
    .gitignore.stub
    bug.yml.stub
    CHANGELOG.md.stub
    CODE_OF_CONDUCT.md.stub
    composer.json.stub
    config.stub
    config.yml.stub
    DebugTest.stub
    install-command.stub
    lang.stub
    LICENSE.md.stub
    messages.php.stub
    migration.stub
    model.stub
    package.json.stub
    page.stub
    Pest.php.stub
    Pest.stub
    phpstan.neon.stub
    phpunit.xml.stub
    pint.json.stub
    plugin.stub
    README.md.stub
    resource.stub
    service-provider.stub
    testbench.yaml.stub
    TestCase.stub
    vite.plugin.stub
    widget.stub
  Support/
    PluginDiscovery.php
    PluginManager.php
    PluginManifest.php
  Testing/
    PluginTestCase.php
  BasePlugin.php
  PluginProvider.php
  PluginsServiceProvider.php
tests/
  Feature/
    McpServerTest.php
    PluginGeneratorTest.php
  Unit/
    Features/
      AbstractFeatureTest.php
      ComposerJsonFeatureTest.php
    Mcp/
      ListComponentTypesToolTest.php
    PluginFeatureFactoryTest.php
    StubProcessorTest.php
  Pest.php
  TestCase.php
.gitignore
CHANGELOG.md
CODE_OF_CONDUCT.md
composer.json
LICENSE.md
phpstan.neon
phpunit.xml
pint.json
README.md
SECURITY.md
testbench.yaml
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".github/ISSUE_TEMPLATE/bug.yml">
name: Bug Report
description: Report a bug
title: "[Bug]: "
labels: ["bug"]
body:
  - type: markdown
    attributes:
      value: |
        Thanks for taking the time to fill out this bug report!
  - type: textarea
    id: description
    attributes:
      label: Description
      description: A clear and concise description of the bug
    validations:
      required: true
  - type: textarea
    id: steps
    attributes:
      label: Steps to Reproduce
      description: Steps to reproduce the behavior
      placeholder: |
        1. Go to '...'
        2. Click on '....'
        3. See error
    validations:
      required: true
  - type: textarea
    id: expected
    attributes:
      label: Expected Behavior
      description: What you expected to happen
    validations:
      required: true
  - type: textarea
    id: actual
    attributes:
      label: Actual Behavior
      description: What actually happened
    validations:
      required: true
  - type: input
    id: version
    attributes:
      label: Package Version
      description: What version of the package are you using?
    validations:
      required: true
  - type: input
    id: php-version
    attributes:
      label: PHP Version
      description: What version of PHP are you using?
    validations:
      required: true
  - type: input
    id: laravel-version
    attributes:
      label: Laravel Version
      description: What version of Laravel are you using?
    validations:
      required: true
</file>

<file path=".github/ISSUE_TEMPLATE/config.yml">
blank_issues_enabled: false
contact_links:
  - name: Ask a question
    url: https://github.com/laravilt/plugins/discussions/new?category=q-a
    about: Ask the community for help
  - name: Request a feature
    url: https://github.com/laravilt/plugins/discussions/new?category=ideas
    about: Share ideas for new features
</file>

<file path=".github/CONTRIBUTING.md">
# Contributing to Laravilt Plugins

Thank you for considering contributing to Laravilt Plugins!

## Pull Requests

1. Fork the repository
2. Create a new branch for your feature
3. Write tests for your changes
4. Ensure all tests pass
5. Submit a pull request

## Coding Standards

- Follow PSR-12 coding standards
- Run `composer format` before committing
- Write tests for new features
- Ensure PHPStan passes with level 5

## Running Tests

```bash
composer test
```

## Code Style

```bash
composer format
```

## Static Analysis

```bash
composer analyse
```
</file>

<file path=".github/dependabot.yml">
version: 2
updates:
  - package-ecosystem: "composer"
    directory: "/"
    schedule:
      interval: "weekly"
    open-pull-requests-limit: 10

  - package-ecosystem: "github-actions"
    directory: "/"
    schedule:
      interval: "weekly"
</file>

<file path=".github/FUNDING.yml">
github: fadymondy
</file>

<file path=".github/SECURITY.md">
# Security Policy

## Reporting a Vulnerability

If you discover a security vulnerability within Laravilt Plugins, please send an email to security@laravilt.com. All security vulnerabilities will be promptly addressed.

Please do not publicly disclose the issue until it has been addressed by the team.
</file>

<file path="src/Commands/Concerns/HandlesFiles.php">
<?php

namespace Laravilt\Plugins\Commands\Concerns;

use Illuminate\Support\Facades\File;

trait HandlesFiles
{
    /**
     * Handle file copy operation with overwrite option.
     */
    public function handleFile(string $from, string $to, string $type = 'file'): void
    {
        $checkIfFileEx = $this->checkFile($to);

        if ($checkIfFileEx) {
            $this->deleteFile($to, $type);
            $this->copyFile($from, $to, $type);
        } else {
            $this->copyFile($from, $to, $type);
        }
    }

    /**
     * Check if file or directory exists.
     */
    public function checkFile(string $path): bool
    {
        return File::exists($path);
    }

    /**
     * Copy file or directory.
     */
    public function copyFile(string $from, string $to, string $type = 'file'): bool
    {
        // Ensure the destination directory exists
        $destinationDir = ($type === 'folder') ? $to : dirname($to);

        if (! File::exists($destinationDir)) {
            File::makeDirectory($destinationDir, 0755, true);
        }

        if ($type === 'folder') {
            $copy = File::copyDirectory($from, $to);
        } else {
            $copy = File::copy($from, $to);
        }

        return $copy;
    }

    /**
     * Delete file or directory.
     */
    public function deleteFile(string $path, string $type = 'file'): bool
    {
        if ($type === 'folder') {
            $delete = File::deleteDirectory($path);
        } else {
            $delete = File::delete($path);
        }

        return $delete;
    }

    /**
     * Ensure directory exists.
     */
    public function ensureDirectoryExists(string $path): void
    {
        if (! File::exists($path)) {
            File::makeDirectory($path, 0755, true);
        }
    }

    /**
     * Move file or directory.
     */
    public function moveFile(string $from, string $to): bool
    {
        return File::move($from, $to);
    }

    /**
     * Create a directory with proper permissions.
     */
    public function createDirectory(string $path, int $mode = 0755, bool $recursive = true): bool
    {
        if (File::exists($path)) {
            return true;
        }

        return File::makeDirectory($path, $mode, $recursive);
    }
}
</file>

<file path="src/Commands/Concerns/ManagesStubs.php">
<?php

namespace Laravilt\Plugins\Commands\Concerns;

use Illuminate\Support\Facades\File;
use Illuminate\Support\Str;

trait ManagesStubs
{
    /**
     * Get stub content.
     */
    protected function getStub(string $name): string
    {
        $stubPath = __DIR__.'/../../Stubs/'.$name.'.stub';

        if (! file_exists($stubPath)) {
            throw new \RuntimeException("Stub file not found: {$stubPath}");
        }

        return file_get_contents($stubPath);
    }

    /**
     * Replace placeholders in stub content.
     */
    protected function replaceInStub(string $stub, array $replacements): string
    {
        foreach ($replacements as $key => $value) {
            $stub = str_replace("{{ {$key} }}", $value, $stub);
        }

        return $stub;
    }

    /**
     * Generate file from stub.
     */
    protected function generateFromStub(string $stubName, string $outputPath, array $replacements): void
    {
        $stub = $this->getStub($stubName);
        $content = $this->replaceInStub($stub, $replacements);

        $this->files->ensureDirectoryExists(dirname($outputPath));
        $this->files->put($outputPath, $content);
    }

    /**
     * Generate file from stub with more options.
     *
     * @param  string  $from  Stub file path
     * @param  string  $to  Output file path
     * @param  array  $replacements  Key-value pairs for replacements
     * @param  array  $directory  Directories to create
     * @param  bool  $append  Whether to append instead of overwrite
     */
    protected function generateStubs(string $from, string $to, array $replacements, array $directory = [], bool $append = false): void
    {
        if (File::exists($from)) {
            $stubValue = File::get($from);

            $convertStubToText = Str::of($stubValue);

            foreach ($replacements as $key => $replacement) {
                $convertStubToText = $convertStubToText->replace('{{ '.$key.' }}', $replacement);
            }

            foreach ($directory as $dir) {
                if (! File::exists($dir)) {
                    File::makeDirectory($dir, 0755, true);
                }
            }

            if (File::exists($to) && ! $append) {
                File::delete($to);
            }

            if ($append) {
                $content = File::get($to);
                if (! str_contains($content, $convertStubToText)) {
                    File::append($to, $convertStubToText);
                }
            } else {
                File::put($to, $convertStubToText);
            }
        }
    }
}
</file>

<file path="src/Commands/Concerns/RunsCommands.php">
<?php

namespace Laravilt\Plugins\Commands\Concerns;

use Symfony\Component\Process\PhpExecutableFinder;
use Symfony\Component\Process\Process;

trait RunsCommands
{
    /**
     * Get the path to the appropriate PHP binary.
     */
    protected function phpBinary(): string
    {
        return (new PhpExecutableFinder)->find(false) ?: 'php';
    }

    /**
     * Run a PHP command.
     */
    public function phpCommand(array $commands, ?bool $useOutput = false): void
    {
        (new Process(array_merge([$this->phpBinary()], $commands), base_path(), ['COMPOSER_MEMORY_LIMIT' => '-1']))
            ->setTimeout(null)
            ->run(function ($type, $output) use ($useOutput) {
                if ($useOutput) {
                    $this->output->write($output);
                }
            });
    }

    /**
     * Run a Yarn command.
     */
    public function yarnCommand(array $commands, ?bool $withOutput = false): void
    {
        (new Process(array_merge(['yarn'], $commands), base_path(), ['COMPOSER_MEMORY_LIMIT' => '-1']))
            ->setTimeout(null)
            ->run(function ($type, $output) use ($withOutput) {
                if ($withOutput) {
                    $this->output->write($output);
                }
            });
    }

    /**
     * Run an npm command.
     */
    public function npmCommand(array $commands, ?bool $withOutput = false): void
    {
        (new Process(array_merge(['npm'], $commands), base_path(), ['COMPOSER_MEMORY_LIMIT' => '-1']))
            ->setTimeout(null)
            ->run(function ($type, $output) use ($withOutput) {
                if ($withOutput) {
                    $this->output->write($output);
                }
            });
    }

    /**
     * Run an artisan command.
     */
    public function artisanCommand(array $command, ?bool $withOutput = false): void
    {
        $this->phpCommand(array_merge(['artisan'], $command), $withOutput);
    }

    /**
     * Installs the given Composer Packages into the application.
     */
    protected function requireComposerPackages(mixed $packages, ?bool $withOutput = false): void
    {
        $command = array_merge(
            ['composer', 'require'],
            is_array($packages) ? $packages : func_get_args()
        );

        (new Process($command, base_path(), ['COMPOSER_MEMORY_LIMIT' => '-1']))
            ->setTimeout(null)
            ->run(function ($type, $output) use ($withOutput) {
                if ($withOutput) {
                    $this->output->write($output);
                }
            });
    }

    /**
     * Install the given Composer Packages as "dev" dependencies.
     */
    protected function requireComposerDevPackages(mixed $packages, ?bool $withOutput = false): void
    {
        $command = array_merge(
            ['composer', 'require', '--dev'],
            is_array($packages) ? $packages : func_get_args()
        );

        (new Process($command, base_path(), ['COMPOSER_MEMORY_LIMIT' => '-1']))
            ->setTimeout(null)
            ->run(function ($type, $output) use ($withOutput) {
                if ($withOutput) {
                    $this->output->write($output);
                }
            });
    }

    /**
     * Run composer install in a specific directory.
     */
    protected function composerInstall(string $directory, ?bool $withOutput = false): void
    {
        (new Process(['composer', 'install'], $directory, ['COMPOSER_MEMORY_LIMIT' => '-1']))
            ->setTimeout(null)
            ->run(function ($type, $output) use ($withOutput) {
                if ($withOutput) {
                    $this->output->write($output);
                }
            });
    }

    /**
     * Run npm install in a specific directory.
     */
    protected function npmInstall(string $directory, ?bool $withOutput = false): void
    {
        (new Process(['npm', 'install'], $directory))
            ->setTimeout(null)
            ->run(function ($type, $output) use ($withOutput) {
                if ($withOutput) {
                    $this->output->write($output);
                }
            });
    }

    /**
     * Run npm build in a specific directory.
     */
    protected function npmBuild(string $directory, ?bool $withOutput = false): void
    {
        (new Process(['npm', 'run', 'build'], $directory))
            ->setTimeout(null)
            ->run(function ($type, $output) use ($withOutput) {
                if ($withOutput) {
                    $this->output->write($output);
                }
            });
    }
}
</file>

<file path="src/Commands/MakeComponentCommand.php">
<?php

namespace Laravilt\Plugins\Commands;

use Illuminate\Console\Command;
use Illuminate\Support\Str;

use function Laravel\Prompts\select;
use function Laravel\Prompts\text;

/**
 * Generate Laravel components within a plugin.
 *
 * This command allows generating various Laravel components
 * (migrations, models, controllers, etc.) within a plugin context.
 */
class MakeComponentCommand extends Command
{
    protected $signature = 'laravilt:make
                            {plugin? : The plugin name}
                            {type? : The component type}
                            {name? : The component name}';

    protected $description = 'Generate Laravel components within a Laravilt plugin';

    protected array $componentTypes = [
        'migration' => 'Database Migration',
        'model' => 'Eloquent Model',
        'controller' => 'Controller',
        'command' => 'Artisan Command',
        'job' => 'Job',
        'event' => 'Event',
        'listener' => 'Event Listener',
        'notification' => 'Notification',
        'seeder' => 'Database Seeder',
        'factory' => 'Model Factory',
        'test' => 'Test',
        'lang' => 'Language File',
        'route' => 'Route',
    ];

    public function handle(): int
    {
        // Get plugin name
        $plugin = $this->argument('plugin') ?: text(
            label: 'Plugin name',
            placeholder: 'e.g., BlogExtensions',
            required: true
        );

        // Get component type
        $type = $this->argument('type') ?: select(
            label: 'What component do you want to generate?',
            options: $this->componentTypes,
            hint: 'Use arrow keys to select'
        );

        // Get component name
        $name = $this->argument('name') ?: text(
            label: ucfirst($this->componentTypes[$type]).' name',
            placeholder: $this->getPlaceholder($type),
            required: true
        );

        // Generate the component
        return $this->generateComponent($plugin, $type, $name);
    }

    protected function generateComponent(string $plugin, string $type, string $name): int
    {
        $pluginPath = $this->getPluginPath($plugin);

        if (! is_dir($pluginPath)) {
            $this->error("Plugin '{$plugin}' not found at {$pluginPath}");

            return self::FAILURE;
        }

        // Get plugin namespace from composer.json
        $namespace = $this->getPluginNamespace($pluginPath);
        if (! $namespace) {
            $this->error('Could not determine plugin namespace from composer.json');

            return self::FAILURE;
        }

        $this->info("Generating {$this->componentTypes[$type]}: {$name}");
        $this->info("Plugin: {$plugin}");
        $this->info("Path: {$pluginPath}");
        $this->info("Namespace: {$namespace}");

        // Call the appropriate generator method
        $method = 'generate'.Str::studly($type);

        if (! method_exists($this, $method)) {
            $this->error("Component type '{$type}' is not yet supported");

            return self::FAILURE;
        }

        return $this->{$method}($pluginPath, $namespace, $name);
    }

    protected function generateMigration(string $pluginPath, string $namespace, string $name): int
    {
        $this->info('Creating migration...');

        $table = Str::snake(Str::pluralStudly($name));
        $migrationName = 'create_'.$table.'_table';
        $className = Str::studly($migrationName);
        $timestamp = date('Y_m_d_His');
        $fileName = $timestamp.'_'.$migrationName.'.php';

        $migrationPath = $pluginPath.'/database/migrations';
        if (! is_dir($migrationPath)) {
            mkdir($migrationPath, 0755, true);
        }

        $stub = $this->getMigrationStub();
        $content = str_replace(
            ['{{ class }}', '{{ table }}'],
            [$className, $table],
            $stub
        );

        file_put_contents($migrationPath.'/'.$fileName, $content);

        $this->info('✅ Migration created successfully!');
        $this->line("Created: database/migrations/{$fileName}");

        return self::SUCCESS;
    }

    protected function generateModel(string $pluginPath, string $namespace, string $name): int
    {
        $this->info('Creating model...');

        $modelPath = $pluginPath.'/src/Models';
        if (! is_dir($modelPath)) {
            mkdir($modelPath, 0755, true);
        }

        $stub = $this->getModelStub();
        $content = str_replace(
            ['{{ namespace }}', '{{ class }}'],
            [$namespace.'\\Models', $name],
            $stub
        );

        file_put_contents($modelPath.'/'.$name.'.php', $content);

        $this->info('✅ Model created successfully!');
        $this->line("Created: src/Models/{$name}.php");

        return self::SUCCESS;
    }

    protected function generateController(string $pluginPath, string $namespace, string $name): int
    {
        $this->info('Creating controller...');

        $controllerPath = $pluginPath.'/src/Http/Controllers';
        if (! is_dir($controllerPath)) {
            mkdir($controllerPath, 0755, true);
        }

        $stub = $this->getControllerStub();
        $content = str_replace(
            ['{{ namespace }}', '{{ class }}'],
            [$namespace.'\\Http\\Controllers', $name],
            $stub
        );

        file_put_contents($controllerPath.'/'.$name.'.php', $content);

        $this->info('✅ Controller created successfully!');
        $this->line("Created: src/Http/Controllers/{$name}.php");

        return self::SUCCESS;
    }

    protected function generateCommand(string $pluginPath, string $namespace, string $name): int
    {
        $this->info('Creating command...');

        $commandPath = $pluginPath.'/src/Commands';
        if (! is_dir($commandPath)) {
            mkdir($commandPath, 0755, true);
        }

        $signature = Str::kebab(str_replace('Command', '', $name));

        $stub = $this->getCommandStub();
        $content = str_replace(
            ['{{ namespace }}', '{{ class }}', '{{ signature }}'],
            [$namespace.'\\Commands', $name, $signature],
            $stub
        );

        file_put_contents($commandPath.'/'.$name.'.php', $content);

        $this->info('✅ Command created successfully!');
        $this->line("Created: src/Commands/{$name}.php");

        return self::SUCCESS;
    }

    protected function generateJob(string $pluginPath, string $namespace, string $name): int
    {
        $this->info('Creating job...');

        $jobPath = $pluginPath.'/src/Jobs';
        if (! is_dir($jobPath)) {
            mkdir($jobPath, 0755, true);
        }

        $stub = $this->getJobStub();
        $content = str_replace(
            ['{{ namespace }}', '{{ class }}'],
            [$namespace.'\\Jobs', $name],
            $stub
        );

        file_put_contents($jobPath.'/'.$name.'.php', $content);

        $this->info('✅ Job created successfully!');
        $this->line("Created: src/Jobs/{$name}.php");

        return self::SUCCESS;
    }

    protected function generateEvent(string $pluginPath, string $namespace, string $name): int
    {
        $this->info('Creating event...');

        $eventPath = $pluginPath.'/src/Events';
        if (! is_dir($eventPath)) {
            mkdir($eventPath, 0755, true);
        }

        $stub = $this->getEventStub();
        $content = str_replace(
            ['{{ namespace }}', '{{ class }}'],
            [$namespace.'\\Events', $name],
            $stub
        );

        file_put_contents($eventPath.'/'.$name.'.php', $content);

        $this->info('✅ Event created successfully!');
        $this->line("Created: src/Events/{$name}.php");

        return self::SUCCESS;
    }

    protected function generateListener(string $pluginPath, string $namespace, string $name): int
    {
        $this->info('Creating listener...');

        $listenerPath = $pluginPath.'/src/Listeners';
        if (! is_dir($listenerPath)) {
            mkdir($listenerPath, 0755, true);
        }

        $stub = $this->getListenerStub();
        $content = str_replace(
            ['{{ namespace }}', '{{ class }}'],
            [$namespace.'\\Listeners', $name],
            $stub
        );

        file_put_contents($listenerPath.'/'.$name.'.php', $content);

        $this->info('✅ Listener created successfully!');
        $this->line("Created: src/Listeners/{$name}.php");

        return self::SUCCESS;
    }

    protected function generateNotification(string $pluginPath, string $namespace, string $name): int
    {
        $this->info('Creating notification...');

        $notificationPath = $pluginPath.'/src/Notifications';
        if (! is_dir($notificationPath)) {
            mkdir($notificationPath, 0755, true);
        }

        $stub = $this->getNotificationStub();
        $content = str_replace(
            ['{{ namespace }}', '{{ class }}'],
            [$namespace.'\\Notifications', $name],
            $stub
        );

        file_put_contents($notificationPath.'/'.$name.'.php', $content);

        $this->info('✅ Notification created successfully!');
        $this->line("Created: src/Notifications/{$name}.php");

        return self::SUCCESS;
    }

    protected function generateSeeder(string $pluginPath, string $namespace, string $name): int
    {
        $this->info('Creating seeder...');

        $seederPath = $pluginPath.'/database/seeders';
        if (! is_dir($seederPath)) {
            mkdir($seederPath, 0755, true);
        }

        $stub = $this->getSeederStub();
        $content = str_replace(
            ['{{ namespace }}', '{{ class }}'],
            [$namespace.'\\Database\\Seeders', $name],
            $stub
        );

        file_put_contents($seederPath.'/'.$name.'.php', $content);

        $this->info('✅ Seeder created successfully!');
        $this->line("Created: database/seeders/{$name}.php");

        return self::SUCCESS;
    }

    protected function generateFactory(string $pluginPath, string $namespace, string $name): int
    {
        $this->info('Creating factory...');

        $factoryPath = $pluginPath.'/database/factories';
        if (! is_dir($factoryPath)) {
            mkdir($factoryPath, 0755, true);
        }

        $modelName = str_replace('Factory', '', $name);

        $stub = $this->getFactoryStub();
        $content = str_replace(
            ['{{ namespace }}', '{{ class }}', '{{ model }}', '{{ modelNamespace }}'],
            [$namespace.'\\Database\\Factories', $name, $modelName, $namespace.'\\Models\\'.$modelName],
            $stub
        );

        file_put_contents($factoryPath.'/'.$name.'.php', $content);

        $this->info('✅ Factory created successfully!');
        $this->line("Created: database/factories/{$name}.php");

        return self::SUCCESS;
    }

    protected function generateTest(string $pluginPath, string $namespace, string $name): int
    {
        $this->info('Creating test...');

        $testPath = $pluginPath.'/tests/Feature';
        if (! is_dir($testPath)) {
            mkdir($testPath, 0755, true);
        }

        $stub = $this->getTestStub();
        $content = str_replace(
            ['{{ namespace }}', '{{ class }}'],
            [$namespace.'\\Tests\\Feature', $name],
            $stub
        );

        file_put_contents($testPath.'/'.$name.'.php', $content);

        $this->info('✅ Test created successfully!');
        $this->line("Created: tests/Feature/{$name}.php");

        return self::SUCCESS;
    }

    protected function generateLang(string $pluginPath, string $namespace, string $name): int
    {
        $this->info('Creating language file...');

        $langPath = $pluginPath.'/resources/lang/'.$name;
        if (! is_dir($langPath)) {
            mkdir($langPath, 0755, true);
        }

        $messagesFile = $langPath.'/messages.php';
        $content = <<<'PHP'
<?php

return [
    // Add your translations here
];

PHP;

        file_put_contents($messagesFile, $content);

        $this->info('✅ Language file created successfully!');
        $this->line("Created: resources/lang/{$name}/messages.php");

        return self::SUCCESS;
    }

    protected function generateRoute(string $pluginPath, string $namespace, string $name): int
    {
        $this->info('Creating route file...');

        $routePath = $pluginPath.'/routes';
        if (! is_dir($routePath)) {
            mkdir($routePath, 0755, true);
        }

        $routeFile = $routePath.'/'.$name.'.php';
        $content = <<<'PHP'
<?php

use Illuminate\Support\Facades\Route;

// Add your routes here

PHP;

        file_put_contents($routeFile, $content);

        $this->info('✅ Route file created successfully!');
        $this->line("Created: routes/{$name}.php");

        return self::SUCCESS;
    }

    protected function getPluginPath(string $plugin): string
    {
        $kebabName = Str::kebab($plugin);

        return base_path("packages/laravilt/{$kebabName}");
    }

    protected function getPluginNamespace(string $pluginPath): ?string
    {
        $composerJsonPath = $pluginPath.'/composer.json';

        if (! file_exists($composerJsonPath)) {
            return null;
        }

        $composerData = json_decode(file_get_contents($composerJsonPath), true);

        if (! isset($composerData['autoload']['psr-4'])) {
            return null;
        }

        // Get the first PSR-4 namespace
        $namespaces = array_keys($composerData['autoload']['psr-4']);

        return rtrim($namespaces[0], '\\');
    }

    protected function getPlaceholder(string $type): string
    {
        return match ($type) {
            'migration' => 'e.g., CreatePostsTable',
            'model' => 'e.g., Post',
            'controller' => 'e.g., PostController',
            'command' => 'e.g., ProcessPostsCommand',
            'job' => 'e.g., ProcessPost',
            'event' => 'e.g., PostCreated',
            'listener' => 'e.g., SendPostNotification',
            'notification' => 'e.g., PostPublished',
            'seeder' => 'e.g., PostSeeder',
            'factory' => 'e.g., PostFactory',
            'test' => 'e.g., PostTest',
            'lang' => 'e.g., en',
            'route' => 'e.g., posts',
            default => 'e.g., Example',
        };
    }

    protected function getMigrationStub(): string
    {
        return <<<'PHP'
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    public function up(): void
    {
        Schema::create('{{ table }}', function (Blueprint $table) {
            $table->id();
            $table->timestamps();
        });
    }

    public function down(): void
    {
        Schema::dropIfExists('{{ table }}');
    }
};

PHP;
    }

    protected function getModelStub(): string
    {
        return <<<'PHP'
<?php

namespace {{ namespace }};

use Illuminate\Database\Eloquent\Model;

class {{ class }} extends Model
{
    protected $fillable = [];
}

PHP;
    }

    protected function getControllerStub(): string
    {
        return <<<'PHP'
<?php

namespace {{ namespace }};

use Illuminate\Http\Request;
use Illuminate\Routing\Controller;

class {{ class }} extends Controller
{
    public function index()
    {
        //
    }
}

PHP;
    }

    protected function getCommandStub(): string
    {
        return <<<'PHP'
<?php

namespace {{ namespace }};

use Illuminate\Console\Command;

class {{ class }} extends Command
{
    protected $signature = '{{ signature }}';

    protected $description = 'Command description';

    public function handle(): int
    {
        $this->info('Command executed successfully!');

        return self::SUCCESS;
    }
}

PHP;
    }

    protected function getJobStub(): string
    {
        return <<<'PHP'
<?php

namespace {{ namespace }};

use Illuminate\Bus\Queueable;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Foundation\Bus\Dispatchable;
use Illuminate\Queue\InteractsWithQueue;
use Illuminate\Queue\SerializesModels;

class {{ class }} implements ShouldQueue
{
    use Dispatchable, InteractsWithQueue, Queueable, SerializesModels;

    public function __construct()
    {
        //
    }

    public function handle(): void
    {
        //
    }
}

PHP;
    }

    protected function getEventStub(): string
    {
        return <<<'PHP'
<?php

namespace {{ namespace }};

use Illuminate\Foundation\Events\Dispatchable;
use Illuminate\Queue\SerializesModels;

class {{ class }}
{
    use Dispatchable, SerializesModels;

    public function __construct()
    {
        //
    }
}

PHP;
    }

    protected function getListenerStub(): string
    {
        return <<<'PHP'
<?php

namespace {{ namespace }};

use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Queue\InteractsWithQueue;

class {{ class }} implements ShouldQueue
{
    use InteractsWithQueue;

    public function __construct()
    {
        //
    }

    public function handle(object $event): void
    {
        //
    }
}

PHP;
    }

    protected function getNotificationStub(): string
    {
        return <<<'PHP'
<?php

namespace {{ namespace }};

use Illuminate\Bus\Queueable;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Notifications\Messages\MailMessage;
use Illuminate\Notifications\Notification;

class {{ class }} extends Notification implements ShouldQueue
{
    use Queueable;

    public function __construct()
    {
        //
    }

    public function via(object $notifiable): array
    {
        return ['mail'];
    }

    public function toMail(object $notifiable): MailMessage
    {
        return (new MailMessage)
            ->line('The introduction to the notification.')
            ->action('Notification Action', url('/'))
            ->line('Thank you for using our application!');
    }

    public function toArray(object $notifiable): array
    {
        return [
            //
        ];
    }
}

PHP;
    }

    protected function getSeederStub(): string
    {
        return <<<'PHP'
<?php

namespace {{ namespace }};

use Illuminate\Database\Seeder;

class {{ class }} extends Seeder
{
    public function run(): void
    {
        //
    }
}

PHP;
    }

    protected function getFactoryStub(): string
    {
        return <<<'PHP'
<?php

namespace {{ namespace }};

use Illuminate\Database\Eloquent\Factories\Factory;
use {{ modelNamespace }};

/**
 * @extends \Illuminate\Database\Eloquent\Factories\Factory<\{{ modelNamespace }}>
 */
class {{ class }} extends Factory
{
    protected $model = {{ model }}::class;

    public function definition(): array
    {
        return [
            //
        ];
    }
}

PHP;
    }

    protected function getTestStub(): string
    {
        return <<<'PHP'
<?php

namespace {{ namespace }};

use Tests\TestCase;

class {{ class }} extends TestCase
{
    public function test_example(): void
    {
        $this->assertTrue(true);
    }
}

PHP;
    }
}
</file>

<file path="src/Concerns/HasAssets.php">
<?php

namespace Laravilt\Plugins\Concerns;

trait HasAssets
{
    protected array $assets = [];

    protected string $assetsPath = 'dist';

    public function assets(array $assets): static
    {
        $this->assets = $assets;

        return $this;
    }

    public function assetsPath(string $path): static
    {
        $this->assetsPath = $path;

        return $this;
    }

    public function getAssets(): array
    {
        return $this->assets;
    }

    public function getAssetsPath(): string
    {
        return $this->assetsPath;
    }

    public function publishAssets(): void
    {
        $pluginId = $this->getId();

        $this->publishes([
            __DIR__."/../../{$this->assetsPath}" => public_path("vendor/{$pluginId}"),
        ], "{$pluginId}-assets");
    }
}
</file>

<file path="src/Concerns/HasCommands.php">
<?php

namespace Laravilt\Plugins\Concerns;

trait HasCommands
{
    protected array $pluginCommands = [];

    public function pluginCommands(array $commands): static
    {
        $this->pluginCommands = $commands;

        return $this;
    }

    public function getPluginCommands(): array
    {
        return $this->pluginCommands;
    }

    public function registerPluginCommands(): void
    {
        if (empty($this->pluginCommands)) {
            return;
        }

        $this->commands($this->pluginCommands);
    }
}
</file>

<file path="src/Concerns/HasComponents.php">
<?php

namespace Laravilt\Plugins\Concerns;

use Illuminate\Support\Str;

trait HasComponents
{
    protected array $components = [];

    public function components(array $components): static
    {
        $this->components = $components;

        return $this;
    }

    public function getComponents(): array
    {
        return $this->components;
    }

    public function registerComponents(): void
    {
        foreach ($this->components as $component) {
            $alias = Str::kebab(class_basename($component));

            $this->app->singleton("laravilt.component.{$alias}", $component);
        }
    }
}
</file>

<file path="src/Concerns/HasMigrations.php">
<?php

namespace Laravilt\Plugins\Concerns;

trait HasMigrations
{
    protected array $migrations = [];

    public function migrations(array $migrations): static
    {
        $this->migrations = $migrations;

        return $this;
    }

    public function getMigrations(): array
    {
        return $this->migrations;
    }

    public function loadMigrations(): void
    {
        if (empty($this->migrations)) {
            return;
        }

        $this->loadMigrationsFrom(
            __DIR__.'/../../database/migrations'
        );
    }
}
</file>

<file path="src/Concerns/HasTranslations.php">
<?php

namespace Laravilt\Plugins\Concerns;

trait HasTranslations
{
    protected array $translationNamespaces = [];

    public function translations(array $namespaces): static
    {
        $this->translationNamespaces = $namespaces;

        return $this;
    }

    public function getTranslationNamespaces(): array
    {
        return $this->translationNamespaces;
    }

    public function loadTranslations(): void
    {
        $pluginId = $this->getId();

        $this->loadTranslationsFrom(
            __DIR__.'/../../resources/lang',
            $pluginId
        );
    }
}
</file>

<file path="src/Concerns/HasViews.php">
<?php

namespace Laravilt\Plugins\Concerns;

trait HasViews
{
    protected string $viewNamespace = '';

    public function viewNamespace(string $namespace): static
    {
        $this->viewNamespace = $namespace;

        return $this;
    }

    public function getViewNamespace(): string
    {
        return $this->viewNamespace ?: $this->getId();
    }

    public function loadViews(): void
    {
        $this->loadViewsFrom(
            __DIR__.'/../../resources/views',
            $this->getViewNamespace()
        );
    }

    public function publishViews(): void
    {
        $namespace = $this->getViewNamespace();

        $this->publishes([
            __DIR__.'/../../resources/views' => resource_path("views/vendor/{$namespace}"),
        ], "{$namespace}-views");
    }
}
</file>

<file path="src/Contracts/Plugin.php">
<?php

namespace Laravilt\Plugins\Contracts;

use Filament\Panel;

interface Plugin extends \Filament\Contracts\Plugin
{
    /**
     * Get the plugin ID.
     */
    public function getId(): string;

    /**
     * Get the plugin name.
     */
    public function getName(): string;

    /**
     * Get the plugin version.
     */
    public function getVersion(): string;

    /**
     * Get the plugin description.
     */
    public function getDescription(): string;

    /**
     * Get the plugin author.
     */
    public function getAuthor(): string;

    /**
     * Register the plugin with a panel.
     */
    public function register(Panel $panel): void;

    /**
     * Boot the plugin for a panel.
     */
    public function boot(Panel $panel): void;

    /**
     * Check if the plugin is enabled.
     */
    public function isEnabled(): bool;

    /**
     * Enable the plugin.
     */
    public function enable(): static;

    /**
     * Disable the plugin.
     */
    public function disable(): static;

    /**
     * Get plugin dependencies.
     *
     * @return array<string>
     */
    public function getDependencies(): array;

    /**
     * Check if dependencies are satisfied.
     */
    public function dependenciesSatisfied(): bool;
}
</file>

<file path="src/Contracts/PluginFeatureInterface.php">
<?php

namespace Laravilt\Plugins\Contracts;

/**
 * Interface for plugin features that can be generated.
 *
 * Each feature (migrations, routes, assets, etc.) implements this interface
 * to determine if it should be generated and how to generate it.
 */
interface PluginFeatureInterface
{
    /**
     * Get the feature name/identifier.
     */
    public function getName(): string;

    /**
     * Determine if this feature should be generated based on config.
     */
    public function shouldGenerate(array $config): bool;

    /**
     * Generate the feature files.
     */
    public function generate(array $config): void;

    /**
     * Get the directories this feature needs.
     */
    public function getDirectories(array $config): array;

    /**
     * Get the priority/order for generation (lower = earlier).
     */
    public function getPriority(): int;
}
</file>

<file path="src/Contracts/PluginManager.php">
<?php

namespace Laravilt\Plugins\Contracts;

use Illuminate\Support\Collection;

interface PluginManager
{
    /**
     * Register a plugin.
     */
    public function register(Plugin $plugin): void;

    /**
     * Boot a plugin by ID.
     */
    public function boot(string $id): void;

    /**
     * Boot all plugins.
     */
    public function bootAll(): void;

    /**
     * Get a plugin by ID.
     */
    public function get(string $id): Plugin;

    /**
     * Check if a plugin is registered.
     */
    public function has(string $id): bool;

    /**
     * Get all plugins.
     *
     * @return Collection<string, Plugin>
     */
    public function all(): Collection;

    /**
     * Get enabled plugins.
     *
     * @return Collection<string, Plugin>
     */
    public function enabled(): Collection;

    /**
     * Discover plugins.
     */
    public function discover(): void;
}
</file>

<file path="src/Facades/LaraviltPlugins.php">
<?php

namespace Laravilt\Plugins\Facades;

use Illuminate\Support\Facades\Facade;
use Laravilt\Plugins\Contracts\PluginManager;

/**
 * LaraviltPlugins Facade for Plugin Management
 *
 * Usage:
 * - LaraviltPlugins::plugin() - Get plugin manager
 * - LaraviltPlugins::plugin('plugin-id') - Get specific plugin
 *
 * @method static void register(\Laravilt\Plugins\Contracts\Plugin $plugin)
 * @method static void boot(string $id)
 * @method static void bootAll()
 * @method static \Laravilt\Plugins\Contracts\Plugin get(string $id)
 * @method static bool has(string $id)
 * @method static \Illuminate\Support\Collection all()
 * @method static \Illuminate\Support\Collection enabled()
 * @method static void discover()
 * @method static \Laravilt\Plugins\Support\PluginManifest getManifest()
 *
 * @see \Laravilt\Plugins\Support\PluginManager
 */
class LaraviltPlugins extends Facade
{
    /**
     * Get the registered name of the component.
     */
    protected static function getFacadeAccessor(): string
    {
        return PluginManager::class;
    }

    /**
     * Get plugin manager instance or specific plugin.
     *
     * @param  string|null  $id  Plugin ID
     */
    public static function plugin(?string $id = null): mixed
    {
        $manager = static::getFacadeRoot();

        if ($id === null) {
            return $manager;
        }

        return $manager->get($id);
    }
}
</file>

<file path="src/Features/AbstractFeature.php">
<?php

namespace Laravilt\Plugins\Features;

use Laravilt\Plugins\Contracts\PluginFeatureInterface;
use Laravilt\Plugins\Services\Generation\StubProcessor;

/**
 * Abstract base class for plugin features.
 *
 * Provides common functionality for all features.
 */
abstract class AbstractFeature implements PluginFeatureInterface
{
    public function __construct(protected StubProcessor $processor) {}

    /**
     * Default priority is 50 (middle priority).
     * Override in subclasses for different priorities:
     * - 0-20: Core files (composer, service provider, etc.)
     * - 21-40: Structure files (migrations, routes, etc.)
     * - 41-60: Asset files (CSS, JS, etc.)
     * - 61-80: Testing files
     * - 81-100: Documentation files
     */
    public function getPriority(): int
    {
        return 50;
    }

    /**
     * Default: no directories needed.
     * Override in subclasses to specify directories.
     */
    public function getDirectories(array $config): array
    {
        return [];
    }
}
</file>

<file path="src/Features/ArtsFeature.php">
<?php

namespace Laravilt\Plugins\Features;

/**
 * Generates arts folder with cover photo for the package.
 *
 * Creates an arts directory with a placeholder screenshot.jpg.
 */
class ArtsFeature extends AbstractFeature
{
    public function getName(): string
    {
        return 'arts';
    }

    public function shouldGenerate(array $config): bool
    {
        return $config['generate_arts'] ?? false;
    }

    public function getPriority(): int
    {
        return 55; // Asset files - after CSS/JS
    }

    public function getDirectories(array $config): array
    {
        return $this->shouldGenerate($config)
            ? ['arts']
            : [];
    }

    public function generate(array $config): void
    {
        $artsPath = $config['base_path'].'/arts';

        // Ensure arts directory exists
        if (! is_dir($artsPath)) {
            mkdir($artsPath, 0755, true);
        }

        // Generate placeholder screenshot
        $this->generatePlaceholderScreenshot($artsPath, $config);
    }

    protected function generatePlaceholderScreenshot(string $artsPath, array $config): void
    {
        $screenshotPath = $artsPath.'/screenshot.jpg';

        // Create a 1200x630 image (standard social media preview size)
        $width = 1200;
        $height = 630;
        $image = imagecreatetruecolor($width, $height);

        // Create dark background with subtle pattern
        $this->createDarkBackground($image, $width, $height);

        // Add plugin icon (rounded square with cyan background)
        $this->addPluginIcon($image, $width, $height);

        // Add plugin name text
        $pluginName = $config['studly_name'];
        $this->addTitle($image, $pluginName, $width, $height);

        // Add description/subtitle
        $description = $config['description'] ?? 'Laravel package for Laravilt';
        $this->addDescription($image, $description, $width, $height);

        // Add Laravilt branding at bottom
        $this->addBranding($image, $width, $height);

        // Save as JPEG
        imagejpeg($image, $screenshotPath, 95);
        imagedestroy($image);
    }

    protected function createDarkBackground($image, int $width, int $height): void
    {
        // Dark background (similar to #0f0f0f or #1a1a1a)
        $darkBg = imagecolorallocate($image, 26, 26, 26);
        imagefilledrectangle($image, 0, 0, $width, $height, $darkBg);

        // Add subtle pattern with circles
        $patternColor = imagecolorallocate($image, 35, 35, 35);
        for ($i = 0; $i < 15; $i++) {
            $circleSize = rand(100, 300);
            $x = rand(-$circleSize, $width);
            $y = rand(-$circleSize, $height);
            imageellipse($image, $x, $y, $circleSize, $circleSize, $patternColor);
        }

        // Add bottom gradient bar (cyan accent)
        $cyanColor = imagecolorallocate($image, 103, 232, 249);
        imagefilledrectangle($image, 0, $height - 8, $width, $height, $cyanColor);
    }

    protected function addPluginIcon($image, int $width, int $height): void
    {
        // Draw rounded square icon with cyan background
        $iconSize = 120;
        $iconX = ($width - $iconSize) / 2;
        $iconY = 120;

        $cyan = imagecolorallocate($image, 103, 232, 249);
        $darkIcon = imagecolorallocate($image, 30, 30, 30);

        // Draw rounded rectangle (simplified as rectangle with GD)
        imagefilledrectangle($image, $iconX, $iconY, $iconX + $iconSize, $iconY + $iconSize, $cyan);

        // Draw plug icon (simplified)
        $plugSize = 60;
        $plugX = ($width - $plugSize) / 2;
        $plugY = $iconY + 30;

        // Plug body
        imagefilledrectangle($image, $plugX + 15, $plugY + 20, $plugX + $plugSize - 15, $plugY + 50, $darkIcon);

        // Plug prongs
        imagefilledrectangle($image, $plugX + 20, $plugY, $plugX + 28, $plugY + 20, $darkIcon);
        imagefilledrectangle($image, $plugX + 32, $plugY, $plugX + 40, $plugY + 20, $darkIcon);
    }

    protected function addTitle($image, string $text, int $width, int $height): void
    {
        // Use built-in font (size 5 is the largest built-in)
        $fontSize = 5;
        $charWidth = imagefontwidth($fontSize);
        $charHeight = imagefontheight($fontSize);

        // Calculate text dimensions
        $textWidth = $charWidth * strlen($text);

        // Center the text below the icon
        $x = ($width - $textWidth) / 2;
        $y = 270;

        // Cyan color for title
        $cyan = imagecolorallocate($image, 103, 232, 249);

        // Draw each character with spacing for better look
        for ($i = 0; $i < strlen($text); $i++) {
            imagechar($image, $fontSize, $x + ($i * $charWidth), $y, $text[$i], $cyan);
        }
    }

    protected function addDescription($image, string $text, int $width, int $height): void
    {
        // Split long text into lines
        $maxLineLength = 80;
        $lines = [];
        $words = explode(' ', $text);
        $currentLine = '';

        foreach ($words as $word) {
            if (strlen($currentLine.' '.$word) <= $maxLineLength) {
                $currentLine .= ($currentLine ? ' ' : '').$word;
            } else {
                if ($currentLine) {
                    $lines[] = $currentLine;
                }
                $currentLine = $word;
            }
        }
        if ($currentLine) {
            $lines[] = $currentLine;
        }

        // Limit to 2 lines
        $lines = array_slice($lines, 0, 2);

        $fontSize = 3;
        $lightCyan = imagecolorallocate($image, 147, 197, 253);
        $startY = 320;

        foreach ($lines as $index => $line) {
            $textWidth = imagefontwidth($fontSize) * strlen($line);
            $x = ($width - $textWidth) / 2;
            $y = $startY + ($index * 20);

            imagestring($image, $fontSize, $x, $y, $line, $lightCyan);
        }
    }

    protected function addBranding($image, int $width, int $height): void
    {
        $brandText = 'Laravilt';
        $fontSize = 4;
        $textWidth = imagefontwidth($fontSize) * strlen($brandText);

        $x = ($width - $textWidth) / 2;
        $y = $height - 80;

        // Gradient colors (purple to cyan)
        $purple = imagecolorallocate($image, 168, 85, 247);
        $cyan = imagecolorallocate($image, 103, 232, 249);

        // Draw text
        imagestring($image, $fontSize, $x, $y, $brandText, $cyan);
    }
}
</file>

<file path="src/Features/ComposerJsonFeature.php">
<?php

namespace Laravilt\Plugins\Features;

/**
 * Generates composer.json for the plugin.
 *
 * Creates package configuration following Laravel package standards.
 */
class ComposerJsonFeature extends AbstractFeature
{
    public function getName(): string
    {
        return 'composer-json';
    }

    public function shouldGenerate(array $config): bool
    {
        return true; // Always generate composer.json
    }

    public function getPriority(): int
    {
        return 1; // Very early - needed by other features
    }

    public function generate(array $config): void
    {
        $this->processor->generateFile(
            $config['base_path'].'/composer.json',
            'composer.json',
            [
                'vendor' => $config['vendor_lower'],
                'package' => $config['kebab_name'],
                'description' => $config['plugin_description'] ?? "{$config['studly_name']} plugin for Laravilt",
                'author' => $config['author'],
                'email' => $config['author_email'] ?? $config['email'],
                'license' => $config['license'],
                'namespace' => str_replace('\\', '\\\\', $config['namespace']),
                'class' => $config['studly_name'].'Plugin',
                'service_provider' => $config['studly_name'].'ServiceProvider',
            ]
        );
    }
}
</file>

<file path="src/Features/ConfigFeature.php">
<?php

namespace Laravilt\Plugins\Features;

/**
 * Generates config file for the plugin.
 *
 * Creates a Laravel configuration file for plugin settings.
 */
class ConfigFeature extends AbstractFeature
{
    public function getName(): string
    {
        return 'config';
    }

    public function shouldGenerate(array $config): bool
    {
        return true; // Always generate config
    }

    public function getPriority(): int
    {
        return 15; // Core file
    }

    public function getDirectories(array $config): array
    {
        return ['config'];
    }

    public function generate(array $config): void
    {
        $this->processor->generateFile(
            $config['base_path'].'/config/'.$config['config_name'].'.php',
            'config',
            [
                'package_name' => $config['studly_name'],
                'env_prefix' => $config['env_prefix'],
            ]
        );
    }
}
</file>

<file path="src/Features/CssFeature.php">
<?php

namespace Laravilt\Plugins\Features;

/**
 * Generates CSS assets for the plugin.
 *
 * Creates CSS files with Tailwind v4 support.
 */
class CssFeature extends AbstractFeature
{
    public function getName(): string
    {
        return 'css';
    }

    public function shouldGenerate(array $config): bool
    {
        return $config['generate_css'] ?? false;
    }

    public function getPriority(): int
    {
        return 50; // Asset files
    }

    public function getDirectories(array $config): array
    {
        return $this->shouldGenerate($config)
            ? ['resources/css', 'dist']
            : [];
    }

    public function generate(array $config): void
    {
        $this->processor->generateFile(
            $config['base_path'].'/resources/css/app.css',
            'css/app',
            [
                'plugin_name' => $config['studly_name'],
            ]
        );
    }
}
</file>

<file path="src/Features/DocumentationFeature.php">
<?php

namespace Laravilt\Plugins\Features;

/**
 * Generates documentation files for the plugin.
 *
 * Creates LICENSE, CHANGELOG, and other documentation files.
 */
class DocumentationFeature extends AbstractFeature
{
    public function getName(): string
    {
        return 'documentation';
    }

    public function shouldGenerate(array $config): bool
    {
        return true; // Always generate documentation files
    }

    public function getPriority(): int
    {
        return 95; // Documentation file - one of the last
    }

    public function generate(array $config): void
    {
        // Generate LICENSE file
        $this->generateLicense($config);

        // Generate CHANGELOG file
        $this->generateChangelog($config);

        // Generate CODE_OF_CONDUCT file
        $this->generateCodeOfConduct($config);
    }

    protected function generateLicense(array $config): void
    {
        $this->processor->generateFile(
            $config['base_path'].'/LICENSE.md',
            'LICENSE.md',
            [
                'license' => $config['license'],
                'author' => $config['author'],
                'year' => date('Y'),
            ]
        );
    }

    protected function generateChangelog(array $config): void
    {
        $this->processor->generateFile(
            $config['base_path'].'/CHANGELOG.md',
            'CHANGELOG.md',
            [
                'plugin_name' => $config['studly_name'],
            ]
        );
    }

    protected function generateCodeOfConduct(array $config): void
    {
        $this->processor->generateFile(
            $config['base_path'].'/CODE_OF_CONDUCT.md',
            'CODE_OF_CONDUCT.md',
            []
        );
    }
}
</file>

<file path="src/Features/GitHubFeature.php">
<?php

namespace Laravilt\Plugins\Features;

/**
 * Generates GitHub files for the plugin.
 *
 * Creates workflows, issue templates, and dependabot configuration.
 */
class GitHubFeature extends AbstractFeature
{
    public function getName(): string
    {
        return 'github';
    }

    public function shouldGenerate(array $config): bool
    {
        return $config['generate_github_files'] ?? false;
    }

    public function getPriority(): int
    {
        return 90; // Documentation file
    }

    public function getDirectories(array $config): array
    {
        return $this->shouldGenerate($config)
            ? [
                '.github',
                '.github/workflows',
                '.github/ISSUE_TEMPLATE',
            ]
            : [];
    }

    public function generate(array $config): void
    {
        // Generate GitHub meta files
        $this->generateContributing($config);
        $this->generateFunding($config);
        $this->generateSecurity($config);

        // Generate workflows
        $this->generateWorkflows($config);

        // Generate issue templates
        $this->generateIssueTemplates($config);

        // Generate dependabot configuration
        $this->generateDependabot($config);
    }

    protected function generateContributing(array $config): void
    {
        $this->processor->generateFile(
            $config['base_path'].'/.github/CONTRIBUTING.md',
            'github/CONTRIBUTING.md',
            [
                'plugin_name' => $config['studly_name'],
            ]
        );
    }

    protected function generateFunding(array $config): void
    {
        if (! empty($config['github_sponsor'])) {
            $this->processor->generateFile(
                $config['base_path'].'/.github/FUNDING.yml',
                'github/FUNDING.yml',
                [
                    'github_username' => $config['github_sponsor'],
                ]
            );
        }
    }

    protected function generateSecurity(array $config): void
    {
        $this->processor->generateFile(
            $config['base_path'].'/.github/SECURITY.md',
            'github/SECURITY.md',
            [
                'plugin_name' => $config['studly_name'],
                'author_email' => $config['author_email'],
            ]
        );
    }

    protected function generateWorkflows(array $config): void
    {
        // Generate tests workflow
        $this->processor->generateFile(
            $config['base_path'].'/.github/workflows/tests.yml',
            'github/workflows/tests.yml',
            [
                'plugin_name' => $config['studly_name'],
            ]
        );

        // Generate PHP code styling workflow
        $this->processor->generateFile(
            $config['base_path'].'/.github/workflows/fix-php-code-styling.yml',
            'github/workflows/fix-php-code-styling.yml',
            [
                'plugin_name' => $config['studly_name'],
            ]
        );

        // Generate dependabot auto-merge workflow
        $this->processor->generateFile(
            $config['base_path'].'/.github/workflows/dependabot-auto-merge.yml',
            'github/workflows/dependabot-auto-merge.yml',
            []
        );
    }

    protected function generateIssueTemplates(array $config): void
    {
        // Generate bug report template (GitHub issue form)
        $this->processor->generateFile(
            $config['base_path'].'/.github/ISSUE_TEMPLATE/bug.yml',
            'github/ISSUE_TEMPLATE/bug.yml',
            []
        );

        // Generate issue template config
        $this->processor->generateFile(
            $config['base_path'].'/.github/ISSUE_TEMPLATE/config.yml',
            'github/ISSUE_TEMPLATE/config.yml',
            [
                'repository_url' => $config['repository_url'] ?? 'https://github.com/'.$config['vendor'].'/'.$config['kebab_name'],
            ]
        );
    }

    protected function generateDependabot(array $config): void
    {
        $this->processor->generateFile(
            $config['base_path'].'/.github/dependabot.yml',
            'github/dependabot.yml',
            []
        );
    }
}
</file>

<file path="src/Features/GitignoreFeature.php">
<?php

namespace Laravilt\Plugins\Features;

/**
 * Generates .gitignore file for the plugin.
 *
 * Creates standard ignore patterns for Laravel packages.
 */
class GitignoreFeature extends AbstractFeature
{
    public function getName(): string
    {
        return 'gitignore';
    }

    public function shouldGenerate(array $config): bool
    {
        return true; // Always generate .gitignore
    }

    public function getPriority(): int
    {
        return 2; // Very early - needed for git initialization
    }

    public function generate(array $config): void
    {
        $this->processor->generateFile(
            $config['base_path'].'/.gitignore',
            '.gitignore',
            []
        );
    }
}
</file>

<file path="src/Features/InstallCommandFeature.php">
<?php

namespace Laravilt\Plugins\Features;

/**
 * Generates install command for the plugin.
 *
 * Creates an Artisan command to install the plugin with conditional features.
 */
class InstallCommandFeature extends AbstractFeature
{
    public function getName(): string
    {
        return 'install-command';
    }

    public function shouldGenerate(array $config): bool
    {
        return true; // Always generate install command
    }

    public function getPriority(): int
    {
        return 12; // Core file - after composer.json
    }

    public function getDirectories(array $config): array
    {
        return ['src/Commands'];
    }

    public function generate(array $config): void
    {
        // Check if any assets are enabled
        $hasAssets = ($config['generate_css'] ?? false) || ($config['generate_js'] ?? false);

        // Build conditional signature options
        $signatureOptions = [];
        if ($hasAssets) {
            $signatureOptions[] = '{--without-assets : Skip asset publishing}';
        }
        if ($config['generate_migrations'] ?? false) {
            $signatureOptions[] = '{--without-migrations : Skip running migrations}';
            $signatureOptions[] = '{--without-seeders : Skip running seeders}';
        }

        // Build conditional method calls
        $calls = [];
        if ($hasAssets) {
            $calls[] = '$this->publishAssets();';
        }
        if ($config['generate_migrations'] ?? false) {
            $calls[] = "\n        if (! \$this->option('without-migrations')) {\n            \$this->runMigrations();\n        }";
            $calls[] = "\n        if (! \$this->option('without-seeders')) {\n            \$this->runSeeders();\n        }";
        }
        if ($hasAssets) {
            $calls[] = "\n        if (! \$this->option('without-assets')) {\n            \$this->buildAssets();\n        }";
        }

        // Build conditional methods
        $methods = [];

        if ($hasAssets) {
            $methods[] = "protected function publishAssets(): void\n    {\n        \$this->info('Publishing assets...');\n\n        \$this->call('vendor:publish', [\n            '--tag' => '{$config['kebab_name']}-assets',\n            '--force' => true,\n        ]);\n\n        \$this->components->success('Assets published successfully!');\n    }";
        }

        if ($config['generate_migrations'] ?? false) {
            $methods[] = "protected function runMigrations(): void\n    {\n        \$this->info('Running migrations...');\n\n        \$this->call('migrate');\n\n        \$this->components->success('Migrations ran successfully!');\n    }";

            $methods[] = "protected function runSeeders(): void\n    {\n        \$this->info('Running seeders...');\n\n        // Add your seeder class here\n        // \$this->call('db:seed', ['--class' => YourSeeder::class]);\n\n        \$this->components->success('Seeders ran successfully!');\n    }";
        }

        if ($hasAssets) {
            $methods[] = "protected function buildAssets(): void\n    {\n        \$this->info('Building assets...');\n\n        \$process = Process::path(base_path('packages/{$config['vendor_lower']}/{$config['kebab_name']}'))\n            ->run('npm install && npm run build');\n\n        if (\$process->successful()) {\n            \$this->components->success('Assets built successfully!');\n        } else {\n            \$this->components->error('Failed to build assets: '.\$process->errorOutput());\n        }\n    }";
        }

        $this->processor->generateFile(
            $config['base_path'].'/src/Commands/Install'.$config['studly_name'].'Command.php',
            'install-command',
            [
                'namespace' => $config['namespace'],
                'class' => 'Install'.$config['studly_name'].'Command',
                'command_name' => $config['kebab_name'].':install',
                'plugin_name' => $config['studly_name'],
                'signature_options' => ! empty($signatureOptions) ? "\n                            ".implode("\n                            ", $signatureOptions) : '',
                'publish_assets_call' => in_array('$this->publishAssets();', $calls) ? '$this->publishAssets();' : '',
                'run_migrations_block' => $this->findInArray($calls, 'runMigrations'),
                'run_seeders_block' => $this->findInArray($calls, 'runSeeders'),
                'build_assets_block' => $this->findInArray($calls, 'buildAssets'),
                'publish_assets_method' => $this->findInArray($methods, 'publishAssets'),
                'run_migrations_method' => $this->findInArray($methods, 'runMigrations'),
                'run_seeders_method' => $this->findInArray($methods, 'runSeeders'),
                'build_assets_method' => $this->findInArray($methods, 'buildAssets'),
            ]
        );
    }

    /**
     * Find a string in array that contains the search term.
     */
    protected function findInArray(array $array, string $search): string
    {
        foreach ($array as $item) {
            if (str_contains($item, $search)) {
                return $item;
            }
        }

        return '';
    }
}
</file>

<file path="src/Features/JsFeature.php">
<?php

namespace Laravilt\Plugins\Features;

/**
 * Generates JavaScript assets for the plugin.
 *
 * Creates Vue.js plugin structure and Vite configuration.
 */
class JsFeature extends AbstractFeature
{
    public function getName(): string
    {
        return 'js';
    }

    public function shouldGenerate(array $config): bool
    {
        return $config['generate_js'] ?? false;
    }

    public function getPriority(): int
    {
        return 51; // Asset files - after CSS
    }

    public function getDirectories(array $config): array
    {
        return $this->shouldGenerate($config)
            ? ['resources/js', 'dist']
            : [];
    }

    public function generate(array $config): void
    {
        // Generate package.json
        $this->generatePackageJson($config);

        // Generate Vite plugin configuration
        $this->generateViteConfig($config);

        // Generate JS file as Vue.js plugin
        $this->generateJsFile($config);
    }

    protected function generatePackageJson(array $config): void
    {
        $this->processor->generateFile(
            $config['base_path'].'/package.json',
            'package.json',
            [
                'package_name' => $config['kebab_name'],
                'description' => $config['plugin_description'] ?? "{$config['studly_name']} plugin for Laravilt",
            ]
        );
    }

    protected function generateViteConfig(array $config): void
    {
        $this->processor->generateFile(
            $config['base_path'].'/vite.plugin.js',
            'vite.plugin',
            [
                'plugin_name' => $config['studly_name'],
                'kebab_name' => $config['kebab_name'],
            ]
        );
    }

    protected function generateJsFile(array $config): void
    {
        $this->processor->generateFile(
            $config['base_path'].'/resources/js/app.js',
            'js/app',
            [
                'plugin_name' => $config['studly_name'],
                'kebab_name' => $config['kebab_name'],
            ]
        );
    }
}
</file>

<file path="src/Features/LanguageFeature.php">
<?php

namespace Laravilt\Plugins\Features;

/**
 * Generates language files for the plugin.
 *
 * Creates translation files for selected languages.
 */
class LanguageFeature extends AbstractFeature
{
    public function getName(): string
    {
        return 'language';
    }

    public function shouldGenerate(array $config): bool
    {
        return ! empty($config['languages']);
    }

    public function getPriority(): int
    {
        return 40; // Structure file
    }

    public function getDirectories(array $config): array
    {
        if (! $this->shouldGenerate($config)) {
            return [];
        }

        $directories = [];
        foreach ($config['languages'] as $lang) {
            $directories[] = "lang/{$lang}";
        }

        return $directories;
    }

    public function generate(array $config): void
    {
        foreach ($config['languages'] as $lang) {
            $this->processor->generateFile(
                $config['base_path']."/lang/{$lang}/{$config['kebab_name']}.php",
                'lang',
                [
                    'package_name' => $config['studly_name'],
                ]
            );
        }
    }
}
</file>

<file path="src/Features/MigrationsFeature.php">
<?php

namespace Laravilt\Plugins\Features;

/**
 * Generates migration directories for the plugin.
 *
 * Creates database/migrations, database/factories, and database/seeders directories.
 */
class MigrationsFeature extends AbstractFeature
{
    public function getName(): string
    {
        return 'migrations';
    }

    public function shouldGenerate(array $config): bool
    {
        return $config['generate_migrations'] ?? false;
    }

    public function getPriority(): int
    {
        return 25; // Structure file
    }

    public function getDirectories(array $config): array
    {
        if ($this->shouldGenerate($config)) {
            return [
                'database/migrations',
                'database/factories',
                'database/seeders',
            ];
        }

        return [];
    }

    public function generate(array $config): void
    {
        // Migrations are created via artisan commands later
        // This feature just ensures the directories exist
    }
}
</file>

<file path="src/Features/PintFeature.php">
<?php

namespace Laravilt\Plugins\Features;

/**
 * Generates Laravel Pint configuration file.
 *
 * Creates pint.json for code formatting.
 */
class PintFeature extends AbstractFeature
{
    public function getName(): string
    {
        return 'pint';
    }

    public function shouldGenerate(array $config): bool
    {
        return true; // Always generate Pint configuration
    }

    public function getPriority(): int
    {
        return 76; // Testing/code quality file
    }

    public function generate(array $config): void
    {
        $this->processor->generateFile(
            $config['base_path'].'/pint.json',
            'pint.json',
            []
        );
    }
}
</file>

<file path="src/Features/PluginClassFeature.php">
<?php

namespace Laravilt\Plugins\Features;

/**
 * Generates the Filament Plugin class.
 *
 * The Plugin class extends PluginProvider and implements the Plugin interface
 * for Filament panel compatibility.
 */
class PluginClassFeature extends AbstractFeature
{
    public function getName(): string
    {
        return 'plugin-class';
    }

    public function shouldGenerate(array $config): bool
    {
        return $config['generate_plugin'] ?? true;
    }

    public function getPriority(): int
    {
        return 10; // Core file - generate early
    }

    public function getDirectories(array $config): array
    {
        return ['src'];
    }

    public function generate(array $config): void
    {
        $this->processor->generateFile(
            $config['base_path'].'/src/'.$config['studly_name'].'Plugin.php',
            'plugin',
            [
                'namespace' => $config['namespace'],
                'class' => $config['studly_name'].'Plugin',
                'id' => $config['kebab_name'],
                'name' => $config['plugin_title'] ?? $config['studly_name'],
                'description' => $config['plugin_description'] ?? "{$config['studly_name']} plugin for Laravilt",
                'author' => $config['author'],
            ]
        );
    }
}
</file>

<file path="src/Features/ReadmeFeature.php">
<?php

namespace Laravilt\Plugins\Features;

/**
 * Generates README.md file for the plugin.
 *
 * Creates comprehensive documentation with badges, installation, and usage instructions.
 */
class ReadmeFeature extends AbstractFeature
{
    public function getName(): string
    {
        return 'readme';
    }

    public function shouldGenerate(array $config): bool
    {
        return true; // Always generate README
    }

    public function getPriority(): int
    {
        return 85; // Documentation file
    }

    public function generate(array $config): void
    {
        // Build badges
        $badges = $this->buildBadges($config);

        // Build Laravilt usage section if plugin is generated
        $laraviltUsage = '';
        if ($config['generate_plugin']) {
            $laraviltUsage = $this->buildLaraviltUsage($config);
        }

        $this->processor->generateFile(
            $config['base_path'].'/README.md',
            'README.md',
            [
                'plugin_name' => $config['studly_name'],
                'description' => $config['plugin_description'] ?? "{$config['studly_name']} plugin for Laravilt",
                'vendor' => $config['vendor_lower'],
                'package' => $config['kebab_name'],
                'config' => $config['kebab_name'],
                'assets_tag' => $config['kebab_name'].'-assets',
                'badges' => $badges,
                'laravilt_usage' => $laraviltUsage,
            ]
        );
    }

    protected function buildBadges(array $config): string
    {
        $vendor = $config['vendor_lower'];
        $package = $config['kebab_name'];
        $githubOrg = $vendor; // Assuming GitHub org matches vendor name

        return <<<BADGES
[![Latest Stable Version](https://poser.pugx.org/{$vendor}/{$package}/version.svg)](https://packagist.org/packages/{$vendor}/{$package})
[![License](https://poser.pugx.org/{$vendor}/{$package}/license.svg)](https://packagist.org/packages/{$vendor}/{$package})
[![Downloads](https://poser.pugx.org/{$vendor}/{$package}/d/total.svg)](https://packagist.org/packages/{$vendor}/{$package})
[![Dependabot Updates](https://github.com/{$githubOrg}/{$package}/actions/workflows/dependabot/dependabot-updates/badge.svg)](https://github.com/{$githubOrg}/{$package}/actions/workflows/dependabot/dependabot-updates)
[![PHP Code Styling](https://github.com/{$githubOrg}/{$package}/actions/workflows/fix-php-code-styling.yml/badge.svg)](https://github.com/{$githubOrg}/{$package}/actions/workflows/fix-php-code-styling.yml)
[![Tests](https://github.com/{$githubOrg}/{$package}/actions/workflows/tests.yml/badge.svg)](https://github.com/{$githubOrg}/{$package}/actions/workflows/tests.yml)
BADGES;
    }

    protected function buildLaraviltUsage(array $config): string
    {
        return <<<USAGE

## Usage

Register the plugin in your Filament panel provider:

```php
use {$config['namespace']}\\{$config['studly_name']}Plugin;

public function panel(Panel \$panel): Panel
{
    return \$panel
        // ...
        ->plugin(new {$config['studly_name']}Plugin());
}
```
USAGE;
    }
}
</file>

<file path="src/Features/RoutesFeature.php">
<?php

namespace Laravilt\Plugins\Features;

/**
 * Generates route files (web and API) for the plugin.
 *
 * Creates routes/web.php and/or routes/api.php based on configuration.
 */
class RoutesFeature extends AbstractFeature
{
    public function getName(): string
    {
        return 'routes';
    }

    public function shouldGenerate(array $config): bool
    {
        return ($config['generate_web_routes'] ?? false) || ($config['generate_api_routes'] ?? false);
    }

    public function getPriority(): int
    {
        return 30; // Structure file
    }

    public function getDirectories(array $config): array
    {
        if ($this->shouldGenerate($config)) {
            return ['routes'];
        }

        return [];
    }

    public function generate(array $config): void
    {
        if ($config['generate_web_routes'] ?? false) {
            $this->generateWebRoutes($config);
        }

        if ($config['generate_api_routes'] ?? false) {
            $this->generateApiRoutes($config);
        }
    }

    protected function generateWebRoutes(array $config): void
    {
        $this->processor->generateFile(
            $config['base_path'].'/routes/web.php',
            'routes/web',
            [
                'name' => $config['studly_name'],
                'kebab_name' => $config['kebab_name'],
            ]
        );
    }

    protected function generateApiRoutes(array $config): void
    {
        $this->processor->generateFile(
            $config['base_path'].'/routes/api.php',
            'routes/api',
            [
                'name' => $config['studly_name'],
                'kebab_name' => $config['kebab_name'],
            ]
        );
    }
}
</file>

<file path="src/Features/ServiceProviderFeature.php">
<?php

namespace Laravilt\Plugins\Features;

/**
 * Generates the Laravel ServiceProvider for the plugin.
 *
 * The ServiceProvider handles package registration, views, translations,
 * migrations, routes, and asset publishing.
 */
class ServiceProviderFeature extends AbstractFeature
{
    public function getName(): string
    {
        return 'service-provider';
    }

    public function shouldGenerate(array $config): bool
    {
        // ServiceProvider is always generated
        return true;
    }

    public function getPriority(): int
    {
        return 5; // Core file - generate early
    }

    public function getDirectories(array $config): array
    {
        return ['src'];
    }

    public function generate(array $config): void
    {
        $viewsLoading = '';
        if ($config['generate_views'] ?? false) {
            $viewsLoading = "        // Load views\n        \$this->loadViewsFrom(__DIR__ . '/../resources/views', '{$config['kebab_name']}');\n";
        }

        $migrationsLoading = '';
        if ($config['generate_migrations'] ?? false) {
            $migrationsLoading = "        // Load migrations\n        \$this->loadMigrationsFrom(__DIR__ . '/../database/migrations');\n";
        }

        $routesLoading = '';
        if ($config['generate_web_routes'] ?? false) {
            $routesLoading .= "\n        // Load web routes\n        \$this->loadRoutesFrom(__DIR__ . '/../routes/web.php');\n";
        }
        if ($config['generate_api_routes'] ?? false) {
            $routesLoading .= "\n        // Load API routes\n        \$this->loadRoutesFrom(__DIR__ . '/../routes/api.php');\n";
        }

        $assetsPublishes = '';
        $hasAssets = ($config['generate_css'] ?? false) || ($config['generate_js'] ?? false);
        if ($hasAssets) {
            $assetsPublishes = "            // Publish assets\n            \$this->publishes([\n                __DIR__ . '/../dist' => public_path('vendor/laravilt/{$config['kebab_name']}'),\n            ], '{$config['assets_tag']}');\n\n";
        }

        $viewsPublishes = '';
        if ($config['generate_views'] ?? false) {
            $viewsPublishes = "            // Publish views\n            \$this->publishes([\n                __DIR__ . '/../resources/views' => resource_path('views/vendor/{$config['kebab_name']}'),\n            ], '{$config['kebab_name']}-views');\n\n";
        }

        $migrationsPublishes = '';
        if ($config['generate_migrations'] ?? false) {
            $migrationsPublishes = "            // Publish migrations\n            \$this->publishes([\n                __DIR__ . '/../database/migrations' => database_path('migrations'),\n            ], '{$config['kebab_name']}-migrations');\n\n";
        }

        $this->processor->generateFile(
            $config['base_path'].'/src/'.$config['studly_name'].'ServiceProvider.php',
            'service-provider',
            [
                'namespace' => $config['namespace'],
                'class' => $config['studly_name'].'ServiceProvider',
                'id' => $config['kebab_name'],
                'config' => $config['config_name'],
                'assets_tag' => $config['assets_tag'],
                'install_command_class' => 'Install'.$config['studly_name'].'Command',
                'views_loading' => $viewsLoading,
                'migrations_loading' => $migrationsLoading,
                'routes_loading' => $routesLoading,
                'assets_publishes' => $assetsPublishes,
                'views_publishes' => $viewsPublishes,
                'migrations_publishes' => $migrationsPublishes,
            ]
        );
    }
}
</file>

<file path="src/Features/TestbenchFeature.php">
<?php

namespace Laravilt\Plugins\Features;

/**
 * Generates Orchestra Testbench configuration file.
 *
 * Creates testbench.yaml for package testing setup.
 */
class TestbenchFeature extends AbstractFeature
{
    public function getName(): string
    {
        return 'testbench';
    }

    public function shouldGenerate(array $config): bool
    {
        return true; // Always generate testbench configuration
    }

    public function getPriority(): int
    {
        return 75; // Testing configuration file
    }

    public function generate(array $config): void
    {
        $this->processor->generateFile(
            $config['base_path'].'/testbench.yaml',
            'testbench.yaml',
            [
                'namespace' => $config['namespace'],
                'service_provider' => $config['studly_name'].'ServiceProvider',
            ]
        );
    }
}
</file>

<file path="src/Features/TestingFeature.php">
<?php

namespace Laravilt\Plugins\Features;

/**
 * Generates testing files for the plugin.
 *
 * Creates PHPUnit, Pest, TestCase, and PHPStan configuration files.
 */
class TestingFeature extends AbstractFeature
{
    public function getName(): string
    {
        return 'testing';
    }

    public function shouldGenerate(array $config): bool
    {
        return true; // Always generate testing files
    }

    public function getPriority(): int
    {
        return 70; // Testing files
    }

    public function getDirectories(array $config): array
    {
        return ['tests', 'tests/Feature', 'tests/Unit'];
    }

    public function generate(array $config): void
    {
        // Generate PHPUnit configuration
        $this->generatePhpUnitXml($config);

        // Generate Pest configuration
        $this->generatePestPhp($config);

        // Generate TestCase
        $this->generateTestCase($config);

        // Generate PHPStan configuration if enabled
        if ($config['generate_phpstan'] ?? false) {
            $this->generatePhpStanNeon($config);
        }

        // Generate debug test
        $this->generateDebugTest($config);
    }

    protected function generatePhpUnitXml(array $config): void
    {
        $this->processor->generateFile(
            $config['base_path'].'/phpunit.xml',
            'phpunit.xml',
            [
                'namespace' => str_replace('\\', '\\\\', $config['namespace']),
            ]
        );
    }

    protected function generatePestPhp(array $config): void
    {
        $this->processor->generateFile(
            $config['base_path'].'/tests/Pest.php',
            'Pest',
            [
                'namespace' => $config['namespace'],
            ]
        );
    }

    protected function generateTestCase(array $config): void
    {
        $hasMigrations = $config['generate_migrations'] ?? false;

        $this->processor->generateFile(
            $config['base_path'].'/tests/TestCase.php',
            'TestCase',
            [
                'namespace' => $config['namespace'],
                'service_provider' => $config['studly_name'].'ServiceProvider',
                'use_refresh_database' => $hasMigrations ? "use Illuminate\Foundation\Testing\RefreshDatabase;\n" : '',
                'use_refresh_database_trait' => $hasMigrations ? "    use RefreshDatabase;\n" : '',
                'load_migrations' => $hasMigrations ? "\n        \$this->loadMigrationsFrom(__DIR__.'/../database/migrations');" : '',
                'database_config' => $hasMigrations ? "\n        config()->set('database.default', 'sqlite');\n        config()->set('database.connections.sqlite.database', ':memory:');" : '',
            ]
        );
    }

    protected function generatePhpStanNeon(array $config): void
    {
        $this->processor->generateFile(
            $config['base_path'].'/phpstan.neon',
            'phpstan.neon',
            []
        );
    }

    protected function generateDebugTest(array $config): void
    {
        $this->processor->generateFile(
            $config['base_path'].'/tests/Feature/DebugTest.php',
            'DebugTest',
            []
        );
    }
}
</file>

<file path="src/Features/ViewsFeature.php">
<?php

namespace Laravilt\Plugins\Features;

/**
 * Generates views directory for the plugin.
 *
 * Creates resources/views structure when views are enabled.
 */
class ViewsFeature extends AbstractFeature
{
    public function getName(): string
    {
        return 'views';
    }

    public function shouldGenerate(array $config): bool
    {
        return $config['generate_views'] ?? false;
    }

    public function getPriority(): int
    {
        return 35; // Structure file
    }

    public function getDirectories(array $config): array
    {
        return $this->shouldGenerate($config)
            ? ['resources/views']
            : [];
    }

    public function generate(array $config): void
    {
        // Create a .gitkeep file to preserve the directory
        $this->processor->files->put(
            $config['base_path'].'/resources/views/.gitkeep',
            ''
        );
    }
}
</file>

<file path="src/Mcp/Tools/GenerateComponentTool.php">
<?php

namespace Laravilt\Plugins\Mcp\Tools;

use Illuminate\JsonSchema\JsonSchema;
use Laravel\Mcp\Request;
use Laravel\Mcp\Response;
use Laravel\Mcp\Server\Tool;

class GenerateComponentTool extends Tool
{
    /**
     * The tool's description.
     */
    protected string $description = 'Generate a Laravel component within a plugin. Supports: migration, model, controller, command, job, event, listener, notification, seeder, factory, test, lang, route';

    /**
     * Handle the tool request.
     */
    public function handle(Request $request): Response
    {
        $plugin = $request->string('plugin');
        $type = $request->string('type');
        $name = $request->string('name');

        $validTypes = ['migration', 'model', 'controller', 'command', 'job', 'event', 'listener', 'notification', 'seeder', 'factory', 'test', 'lang', 'route'];

        if (! in_array($type, $validTypes)) {
            return Response::text('❌ Invalid component type. Valid types: '.implode(', ', $validTypes));
        }

        $command = 'php '.base_path('artisan')." laravilt:make {$plugin} {$type} {$name}";

        exec($command, $output, $returnCode);

        if ($returnCode === 0) {
            return Response::text("✅ Component created successfully!\n\n".implode("\n", $output));
        } else {
            return Response::text('❌ Failed to create component: '.implode("\n", $output));
        }
    }

    /**
     * Get the tool's input schema.
     *
     * @return array<string, \Illuminate\JsonSchema\JsonSchema>
     */
    public function schema(JsonSchema $schema): array
    {
        return [
            'plugin' => $schema->string()
                ->description('Plugin name (kebab-case)')
                ->required(),
            'type' => $schema->string()
                ->description('Component type (migration, model, controller, command, job, event, listener, notification, seeder, factory, test, lang, route)')
                ->enum(['migration', 'model', 'controller', 'command', 'job', 'event', 'listener', 'notification', 'seeder', 'factory', 'test', 'lang', 'route'])
                ->required(),
            'name' => $schema->string()
                ->description('Component name (e.g., "Post", "CreatePostsTable", "PostController")')
                ->required(),
        ];
    }
}
</file>

<file path="src/Mcp/Tools/GeneratePluginTool.php">
<?php

namespace Laravilt\Plugins\Mcp\Tools;

use Illuminate\JsonSchema\JsonSchema;
use Illuminate\Support\Str;
use Laravel\Mcp\Request;
use Laravel\Mcp\Response;
use Laravel\Mcp\Server\Tool;

class GeneratePluginTool extends Tool
{
    /**
     * The tool's description.
     */
    protected string $description = <<<'MARKDOWN'
        Generate a new Laravilt plugin with specified features. Creates complete plugin structure with service provider, config, and optional features like migrations, views, assets, GitHub workflows, etc.
    MARKDOWN;

    /**
     * Handle the tool request.
     */
    public function handle(Request $request): Response
    {
        $name = $request->string('name');
        $description = $request->string('description', '');
        $migrations = $request->boolean('migrations', false);
        $views = $request->boolean('views', false);
        $webRoutes = $request->boolean('webRoutes', false);
        $apiRoutes = $request->boolean('apiRoutes', false);
        $css = $request->boolean('css', false);
        $js = $request->boolean('js', false);
        $arts = $request->boolean('arts', true);
        $github = $request->boolean('github', true);
        $phpstan = $request->boolean('phpstan', true);

        $command = 'php '.base_path('artisan').' laravilt:plugin "'.$name.'" --no-interaction';

        exec($command, $output, $returnCode);

        if ($returnCode === 0) {
            $kebabName = Str::kebab($name);
            $pluginPath = base_path("packages/laravilt/{$kebabName}");

            $response = "✅ Plugin '{$name}' created successfully!\n\n";
            $response .= "📖 Location: {$pluginPath}\n\n";
            $response .= "📦 Next steps:\n";
            $response .= "1. Require the plugin in your composer.json\n";
            $response .= "2. Run: composer install\n";
            $response .= "3. Run: php artisan {$kebabName}:install\n";
            $response .= "4. Register the plugin in your Filament panel provider\n";

            return Response::text($response);
        } else {
            return Response::text('❌ Failed to create plugin: '.implode("\n", $output));
        }
    }

    /**
     * Get the tool's input schema.
     *
     * @return array<string, \Illuminate\JsonSchema\JsonSchema>
     */
    public function schema(JsonSchema $schema): array
    {
        return [
            'name' => $schema->string()
                ->description('Plugin name in StudlyCase (e.g., "BlogExtensions")')
                ->required(),
            'description' => $schema->string()
                ->description('Plugin description'),
            'migrations' => $schema->boolean()
                ->description('Include database migrations')
                ->default(false),
            'views' => $schema->boolean()
                ->description('Include Blade views')
                ->default(false),
            'webRoutes' => $schema->boolean()
                ->description('Include web routes')
                ->default(false),
            'apiRoutes' => $schema->boolean()
                ->description('Include API routes')
                ->default(false),
            'css' => $schema->boolean()
                ->description('Include CSS assets (Tailwind v4)')
                ->default(false),
            'js' => $schema->boolean()
                ->description('Include JavaScript assets (Vue.js)')
                ->default(false),
            'arts' => $schema->boolean()
                ->description('Include arts folder with cover photo')
                ->default(true),
            'github' => $schema->boolean()
                ->description('Include GitHub workflows and templates')
                ->default(true),
            'phpstan' => $schema->boolean()
                ->description('Include PHPStan configuration')
                ->default(true),
        ];
    }
}
</file>

<file path="src/Mcp/Tools/ListComponentTypesTool.php">
<?php

namespace Laravilt\Plugins\Mcp\Tools;

use Illuminate\JsonSchema\JsonSchema;
use Laravel\Mcp\Request;
use Laravel\Mcp\Response;
use Laravel\Mcp\Server\Tool;

class ListComponentTypesTool extends Tool
{
    /**
     * The tool's description.
     */
    protected string $description = 'List all available component types that can be generated within a plugin';

    /**
     * Handle the tool request.
     */
    public function handle(Request $request): Response
    {
        $types = [
            'migration' => 'Database Migration - Creates a new database migration',
            'model' => 'Eloquent Model - Creates a new model class',
            'controller' => 'Controller - Creates a new controller',
            'command' => 'Artisan Command - Creates a new console command',
            'job' => 'Job - Creates a new queueable job',
            'event' => 'Event - Creates a new event class',
            'listener' => 'Event Listener - Creates a new event listener',
            'notification' => 'Notification - Creates a new notification',
            'seeder' => 'Database Seeder - Creates a new database seeder',
            'factory' => 'Model Factory - Creates a new model factory',
            'test' => 'Test - Creates a new feature test',
            'lang' => 'Language File - Creates a new language file',
            'route' => 'Route - Creates a new route file',
        ];

        $output = "Available Component Types:\n\n";
        foreach ($types as $type => $description) {
            $output .= "📝 {$type}\n   {$description}\n\n";
        }

        return Response::text($output);
    }

    /**
     * Get the tool's input schema.
     *
     * @return array<string, \Illuminate\JsonSchema\JsonSchema>
     */
    public function schema(JsonSchema $schema): array
    {
        return [];
    }
}
</file>

<file path="src/Mcp/Tools/ListPluginsTool.php">
<?php

namespace Laravilt\Plugins\Mcp\Tools;

use Illuminate\JsonSchema\JsonSchema;
use Illuminate\Support\Facades\File;
use Laravel\Mcp\Request;
use Laravel\Mcp\Response;
use Laravel\Mcp\Server\Tool;

class ListPluginsTool extends Tool
{
    /**
     * The tool's description.
     */
    protected string $description = 'List all installed Laravilt plugins in the packages directory';

    /**
     * Handle the tool request.
     */
    public function handle(Request $request): Response
    {
        $pluginsPath = base_path('packages/laravilt');

        if (! File::isDirectory($pluginsPath)) {
            return Response::text('No plugins directory found.');
        }

        $plugins = [];
        $directories = File::directories($pluginsPath);

        foreach ($directories as $dir) {
            $composerJsonPath = $dir.'/composer.json';
            if (File::exists($composerJsonPath)) {
                $composerData = json_decode(File::get($composerJsonPath), true);
                $plugins[] = [
                    'name' => basename($dir),
                    'package' => $composerData['name'] ?? 'N/A',
                    'description' => $composerData['description'] ?? 'N/A',
                    'version' => $composerData['version'] ?? 'N/A',
                    'path' => $dir,
                ];
            }
        }

        if (empty($plugins)) {
            return Response::text('No plugins found in packages/laravilt directory.');
        }

        $output = 'Found '.count($plugins)." plugin(s):\n\n";
        foreach ($plugins as $plugin) {
            $output .= "📦 {$plugin['name']}\n";
            $output .= "   Package: {$plugin['package']}\n";
            $output .= "   Version: {$plugin['version']}\n";
            $output .= "   Description: {$plugin['description']}\n";
            $output .= "   Path: {$plugin['path']}\n\n";
        }

        return Response::text($output);
    }

    /**
     * Get the tool's input schema.
     *
     * @return array<string, \Illuminate\JsonSchema\JsonSchema>
     */
    public function schema(JsonSchema $schema): array
    {
        return [];
    }
}
</file>

<file path="src/Mcp/Tools/PluginInfoTool.php">
<?php

namespace Laravilt\Plugins\Mcp\Tools;

use Illuminate\JsonSchema\JsonSchema;
use Illuminate\Support\Facades\File;
use Laravel\Mcp\Request;
use Laravel\Mcp\Response;
use Laravel\Mcp\Server\Tool;

class PluginInfoTool extends Tool
{
    /**
     * The tool's description.
     */
    protected string $description = 'Get detailed information about a specific plugin including its structure, features, and configuration';

    /**
     * Handle the tool request.
     */
    public function handle(Request $request): Response
    {
        $plugin = $request->string('plugin');
        $pluginPath = base_path("packages/laravilt/{$plugin}");

        if (! File::isDirectory($pluginPath)) {
            return Response::text("Plugin '{$plugin}' not found at {$pluginPath}");
        }

        $info = [];

        // Composer info
        $composerJsonPath = $pluginPath.'/composer.json';
        if (File::exists($composerJsonPath)) {
            $composerData = json_decode(File::get($composerJsonPath), true);
            $info['composer'] = $composerData;
        }

        // Directory structure
        $info['structure'] = $this->getDirectoryStructure($pluginPath);

        // Features
        $info['features'] = [
            'migrations' => File::isDirectory($pluginPath.'/database/migrations'),
            'models' => File::isDirectory($pluginPath.'/src/Models'),
            'controllers' => File::isDirectory($pluginPath.'/src/Http/Controllers'),
            'views' => File::isDirectory($pluginPath.'/resources/views'),
            'routes' => File::isDirectory($pluginPath.'/routes'),
            'css' => File::isDirectory($pluginPath.'/resources/css'),
            'js' => File::isDirectory($pluginPath.'/resources/js'),
            'tests' => File::isDirectory($pluginPath.'/tests'),
            'github' => File::isDirectory($pluginPath.'/.github'),
            'arts' => File::isDirectory($pluginPath.'/arts'),
        ];

        $output = "Plugin: {$plugin}\n\n";
        $output .= "📦 Package Information:\n";
        $output .= "   Name: {$info['composer']['name']}\n";
        $output .= "   Description: {$info['composer']['description']}\n";
        $output .= "   Version: {$info['composer']['version']}\n\n";

        $output .= "📁 Structure:\n";
        foreach ($info['structure'] as $item) {
            $output .= "   {$item}\n";
        }

        $output .= "\n✨ Features:\n";
        foreach ($info['features'] as $feature => $exists) {
            $status = $exists ? '✅' : '❌';
            $output .= "   {$status} ".ucfirst($feature)."\n";
        }

        return Response::text($output);
    }

    /**
     * Get the tool's input schema.
     *
     * @return array<string, \Illuminate\JsonSchema\JsonSchema>
     */
    public function schema(JsonSchema $schema): array
    {
        return [
            'plugin' => $schema->string()
                ->description('The plugin name (kebab-case, e.g., "blog-extensions")')
                ->required(),
        ];
    }

    protected function getDirectoryStructure(string $path): array
    {
        $structure = [];
        $directories = File::directories($path);

        foreach ($directories as $dir) {
            $structure[] = basename($dir);
        }

        return $structure;
    }
}
</file>

<file path="src/Mcp/Tools/SearchDocsTool.php">
<?php

namespace Laravilt\Plugins\Mcp\Tools;

use Illuminate\JsonSchema\JsonSchema;
use Illuminate\Support\Facades\File;
use Laravel\Mcp\Request;
use Laravel\Mcp\Response;
use Laravel\Mcp\Server\Tool;

class SearchDocsTool extends Tool
{
    /**
     * The tool's description.
     */
    protected string $description = 'Search the Laravilt Plugins documentation to understand features, architecture, and usage';

    /**
     * Handle the tool request.
     */
    public function handle(Request $request): Response
    {
        $query = $request->string('query');
        $pluginsPath = base_path('packages/laravilt/plugins');

        // Collect all documentation files
        $docFiles = $this->getDocumentationFiles($pluginsPath);

        // Search through documentation
        $results = $this->searchDocumentation($docFiles, $query);

        if (empty($results)) {
            return Response::text("No documentation found matching '{$query}'.");
        }

        // Format results
        $output = "Documentation Search Results for: {$query}\n\n";
        $output .= 'Found '.count($results)." relevant section(s):\n\n";

        foreach ($results as $result) {
            $output .= "📄 {$result['file']}\n";
            $output .= str_repeat('=', 60)."\n\n";
            $output .= $result['content']."\n\n";
            $output .= str_repeat('-', 60)."\n\n";
        }

        return Response::text($output);
    }

    /**
     * Get the tool's input schema.
     *
     * @return array<string, \Illuminate\JsonSchema\JsonSchema>
     */
    public function schema(JsonSchema $schema): array
    {
        return [
            'query' => $schema->string()
                ->description('Search query (e.g., "plugin generation", "MCP tools", "factory pattern", "component types")')
                ->required(),
        ];
    }

    /**
     * Get all documentation files.
     */
    protected function getDocumentationFiles(string $path): array
    {
        $files = [];

        // README.md - Main documentation
        if (File::exists($path.'/README.md')) {
            $files[] = [
                'path' => $path.'/README.md',
                'name' => 'README.md',
                'content' => File::get($path.'/README.md'),
            ];
        }

        // All docs/ files
        $docsPath = $path.'/docs';
        if (File::isDirectory($docsPath)) {
            foreach (File::allFiles($docsPath) as $file) {
                if ($file->getExtension() === 'md') {
                    $relativePath = str_replace($path.'/', '', $file->getPathname());
                    $files[] = [
                        'path' => $file->getPathname(),
                        'name' => $relativePath,
                        'content' => File::get($file->getPathname()),
                    ];
                }
            }
        }

        return $files;
    }

    /**
     * Search documentation files for relevant content.
     */
    protected function searchDocumentation(array $files, string $query): array
    {
        $results = [];
        $queryLower = strtolower($query);
        $keywords = explode(' ', $queryLower);

        foreach ($files as $file) {
            $content = $file['content'];
            $contentLower = strtolower($content);

            // Check if any keyword matches
            $matchCount = 0;
            foreach ($keywords as $keyword) {
                if (stripos($contentLower, $keyword) !== false) {
                    $matchCount++;
                }
            }

            // If matches found, extract relevant sections
            if ($matchCount > 0) {
                $sections = $this->extractRelevantSections($content, $query, $keywords);

                foreach ($sections as $section) {
                    $results[] = [
                        'file' => $file['name'],
                        'content' => $section,
                        'relevance' => $matchCount,
                    ];
                }
            }
        }

        // Sort by relevance (highest first)
        usort($results, fn ($a, $b) => $b['relevance'] <=> $a['relevance']);

        // Limit to top 5 most relevant results
        return array_slice($results, 0, 5);
    }

    /**
     * Extract relevant sections from content based on query.
     */
    protected function extractRelevantSections(string $content, string $query, array $keywords): array
    {
        $sections = [];
        $lines = explode("\n", $content);

        // Split by markdown headers to get sections
        $currentSection = '';
        $currentHeader = '';
        $inRelevantSection = false;

        foreach ($lines as $line) {
            // Check if line is a header
            if (preg_match('/^#+\s+(.+)$/', $line, $matches)) {
                // Save previous section if it was relevant
                if ($inRelevantSection && ! empty(trim($currentSection))) {
                    $sections[] = trim($currentHeader."\n\n".$currentSection);
                }

                // Start new section
                $currentHeader = $line;
                $currentSection = '';

                // Check if header is relevant
                $headerLower = strtolower($matches[1]);
                $inRelevantSection = false;
                foreach ($keywords as $keyword) {
                    if (stripos($headerLower, $keyword) !== false) {
                        $inRelevantSection = true;
                        break;
                    }
                }
            } else {
                // Add to current section
                $currentSection .= $line."\n";

                // Check if content line is relevant
                if (! $inRelevantSection) {
                    $lineLower = strtolower($line);
                    foreach ($keywords as $keyword) {
                        if (stripos($lineLower, $keyword) !== false) {
                            $inRelevantSection = true;
                            break;
                        }
                    }
                }
            }
        }

        // Save last section if relevant
        if ($inRelevantSection && ! empty(trim($currentSection))) {
            $sections[] = trim($currentHeader."\n\n".$currentSection);
        }

        // If no sections found, return intro (first 50 lines that match)
        if (empty($sections)) {
            $matchingLines = [];
            foreach ($lines as $line) {
                $lineLower = strtolower($line);
                foreach ($keywords as $keyword) {
                    if (stripos($lineLower, $keyword) !== false) {
                        $matchingLines[] = $line;
                        if (count($matchingLines) >= 50) {
                            break 2;
                        }
                        break;
                    }
                }
            }

            if (! empty($matchingLines)) {
                $sections[] = implode("\n", $matchingLines);
            }
        }

        return $sections;
    }
}
</file>

<file path="src/Services/Generation/StubProcessor.php">
<?php

namespace Laravilt\Plugins\Services\Generation;

use Illuminate\Filesystem\Filesystem;

/**
 * Processes stub files by replacing placeholders with actual values.
 *
 * This class is responsible for loading stub templates and performing
 * placeholder replacement to generate final file content.
 */
class StubProcessor
{
    public function __construct(public Filesystem $files) {}

    /**
     * Get stub path from stub name.
     */
    protected function getStubPath(string $name): string
    {
        return __DIR__.'/../../Stubs/'.$name.'.stub';
    }

    /**
     * Get processed stub content with replacements.
     *
     * @param  string  $stubName  Name of the stub file (without .stub extension)
     * @param  array  $replacements  Key-value pairs for placeholder replacement
     * @return string Processed stub content
     *
     * @throws \RuntimeException if stub file not found
     */
    public function process(string $stubName, array $replacements): string
    {
        $stubPath = $this->getStubPath($stubName);

        if (! $this->files->exists($stubPath)) {
            throw new \RuntimeException("Stub file not found: {$stubPath}");
        }

        $stub = $this->files->get($stubPath);

        foreach ($replacements as $key => $value) {
            $stub = str_replace("{{ {$key} }}", $value, $stub);
        }

        return $stub;
    }

    /**
     * Generate file from stub with replacements.
     *
     * @param  string  $path  Full path where file should be created
     * @param  string  $stubName  Name of the stub file
     * @param  array  $replacements  Placeholder replacements
     */
    public function generateFile(string $path, string $stubName, array $replacements): void
    {
        $content = $this->process($stubName, $replacements);
        $this->files->ensureDirectoryExists(dirname($path));
        $this->files->put($path, $content);
    }
}
</file>

<file path="src/Services/PluginFeatureFactory.php">
<?php

namespace Laravilt\Plugins\Services;

use Laravilt\Plugins\Contracts\PluginFeatureInterface;

/**
 * Factory for managing and executing plugin features.
 *
 * This class follows the Factory Pattern to allow dynamic registration
 * and execution of plugin features without modifying core code.
 */
class PluginFeatureFactory
{
    /**
     * @var array<PluginFeatureInterface>
     */
    protected array $features = [];

    /**
     * Register a feature for generation.
     */
    public function register(PluginFeatureInterface $feature): void
    {
        $this->features[$feature->getName()] = $feature;
    }

    /**
     * Register multiple features at once.
     *
     * @param  array<PluginFeatureInterface>  $features
     */
    public function registerMany(array $features): void
    {
        foreach ($features as $feature) {
            $this->register($feature);
        }
    }

    /**
     * Get all registered features sorted by priority.
     *
     * @return array<PluginFeatureInterface>
     */
    public function getFeatures(): array
    {
        $features = $this->features;

        usort($features, fn ($a, $b) => $a->getPriority() <=> $b->getPriority());

        return $features;
    }

    /**
     * Get directories needed by all features that should be generated.
     */
    public function getDirectories(array $config): array
    {
        $directories = [];

        foreach ($this->getFeatures() as $feature) {
            if ($feature->shouldGenerate($config)) {
                $directories = array_merge($directories, $feature->getDirectories($config));
            }
        }

        return array_unique($directories);
    }

    /**
     * Generate all features that should be generated.
     */
    public function generateAll(array $config): void
    {
        foreach ($this->getFeatures() as $feature) {
            if ($feature->shouldGenerate($config)) {
                $feature->generate($config);
            }
        }
    }

    /**
     * Generate a specific feature by name.
     */
    public function generate(string $featureName, array $config): void
    {
        if (! isset($this->features[$featureName])) {
            throw new \InvalidArgumentException("Feature '{$featureName}' not registered");
        }

        $feature = $this->features[$featureName];

        if ($feature->shouldGenerate($config)) {
            $feature->generate($config);
        }
    }
}
</file>

<file path="src/Stubs/css/app.stub">
@import "tailwindcss";

/**
 * {{ plugin_name }} Styles
 *
 * Custom theme configuration for Tailwind CSS v4
 *
 * @theme {
 *   --color-primary: oklch(0.72 0.11 178);
 *   --color-secondary: oklch(0.65 0.15 250);
 * }
 */
</file>

<file path="src/Stubs/github/ISSUE_TEMPLATE/bug_report.md.stub">
---
name: Bug report
about: Create a report to help us improve {{ plugin_name }}
title: '[BUG] '
labels: bug
assignees: ''
---

**Describe the bug**
A clear and concise description of what the bug is.

**To Reproduce**
Steps to reproduce the behavior:
1. Go to '...'
2. Click on '....'
3. Scroll down to '....'
4. See error

**Expected behavior**
A clear and concise description of what you expected to happen.

**Screenshots**
If applicable, add screenshots to help explain your problem.

**Environment:**
 - PHP Version: [e.g. 8.2]
 - Laravel Version: [e.g. 11.0]
 - {{ plugin_name }} Version: [e.g. 1.0.0]

**Additional context**
Add any other context about the problem here.
</file>

<file path="src/Stubs/github/ISSUE_TEMPLATE/bug.yml.stub">
name: Bug Report
description: Report a bug
title: "[Bug]: "
labels: ["bug"]
body:
  - type: markdown
    attributes:
      value: |
        Thanks for taking the time to fill out this bug report!
  - type: textarea
    id: description
    attributes:
      label: Description
      description: A clear and concise description of the bug
    validations:
      required: true
  - type: textarea
    id: steps
    attributes:
      label: Steps to Reproduce
      description: Steps to reproduce the behavior
      placeholder: |
        1. Go to '...'
        2. Click on '....'
        3. See error
    validations:
      required: true
  - type: textarea
    id: expected
    attributes:
      label: Expected Behavior
      description: What you expected to happen
    validations:
      required: true
  - type: textarea
    id: actual
    attributes:
      label: Actual Behavior
      description: What actually happened
    validations:
      required: true
  - type: input
    id: version
    attributes:
      label: Package Version
      description: What version of the package are you using?
    validations:
      required: true
  - type: input
    id: php-version
    attributes:
      label: PHP Version
      description: What version of PHP are you using?
    validations:
      required: true
  - type: input
    id: laravel-version
    attributes:
      label: Laravel Version
      description: What version of Laravel are you using?
    validations:
      required: true
</file>

<file path="src/Stubs/github/ISSUE_TEMPLATE/config.yml.stub">
blank_issues_enabled: false
contact_links:
  - name: Ask a question
    url: {{ repository_url }}/discussions/new?category=q-a
    about: Ask the community for help
  - name: Request a feature
    url: {{ repository_url }}/discussions/new?category=ideas
    about: Share ideas for new features
</file>

<file path="src/Stubs/github/ISSUE_TEMPLATE/feature_request.md.stub">
---
name: Feature request
about: Suggest an idea for {{ plugin_name }}
title: '[FEATURE] '
labels: enhancement
assignees: ''
---

**Is your feature request related to a problem? Please describe.**
A clear and concise description of what the problem is. Ex. I'm always frustrated when [...]

**Describe the solution you'd like**
A clear and concise description of what you want to happen.

**Describe alternatives you've considered**
A clear and concise description of any alternative solutions or features you've considered.

**Additional context**
Add any other context or screenshots about the feature request here.
</file>

<file path="src/Stubs/github/workflows/dependabot-auto-merge.yml.stub">
name: Dependabot Auto-Merge

on: [push, pull_request]

permissions:
  pull-requests: write
  contents: write

jobs:
  dependabot:
    runs-on: ubuntu-latest
    if: ${{ github.actor == 'dependabot[bot]' }}
    steps:
      - name: Dependabot metadata
        id: metadata
        uses: dependabot/fetch-metadata@v2
        with:
          github-token: "${{ secrets.GITHUB_TOKEN }}"

      - name: Auto-merge Dependabot PRs for semver-minor updates
        if: ${{steps.metadata.outputs.update-type == 'version-update:semver-minor'}}
        run: gh pr merge --auto --merge "$PR_URL"
        env:
          PR_URL: ${{github.event.pull_request.html_url}}
          GITHUB_TOKEN: ${{secrets.GITHUB_TOKEN}}

      - name: Auto-merge Dependabot PRs for semver-patch updates
        if: ${{steps.metadata.outputs.update-type == 'version-update:semver-patch'}}
        run: gh pr merge --auto --merge "$PR_URL"
        env:
          PR_URL: ${{github.event.pull_request.html_url}}
          GITHUB_TOKEN: ${{secrets.GITHUB_TOKEN}}
</file>

<file path="src/Stubs/github/workflows/fix-php-code-styling.yml.stub">
name: Fix PHP Code Styling

on:
  push:
    branches: [ "master", "main" ]

permissions:
  contents: write

jobs:
  php-code-styling:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.head_ref }}

      - name: Fix PHP code style issues
        uses: aglipanci/laravel-pint-action@2.4
        with:
          preset: laravel

      - name: Commit changes
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          commit_message: Fix styling
</file>

<file path="src/Stubs/github/workflows/tests.yml.stub">
name: Tests

on:
  push:
    branches: [ "master", "main" ]
  pull_request:
    branches: [ "master", "main" ]

jobs:
  test:
    runs-on: ubuntu-latest
    strategy:
      fail-fast: true
      matrix:
        php: [8.2, 8.3]
        laravel: [11.*]
        dependency-version: [prefer-stable]

    name: PHP ${{ matrix.php }} - Laravel ${{ matrix.laravel }} - ${{ matrix.dependency-version }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup PHP
        uses: shivammathur/setup-php@v2
        with:
          php-version: ${{ matrix.php }}
          extensions: dom, curl, libxml, mbstring, zip, pcntl, pdo, sqlite, pdo_sqlite, bcmath, soap, intl, gd, exif, iconv
          coverage: none

      - name: Setup problem matchers
        run: |
          echo "::add-matcher::${{ runner.tool_cache }}/php.json"
          echo "::add-matcher::${{ runner.tool_cache }}/phpunit.json"

      - name: Install dependencies
        run: |
          composer require "laravel/framework:${{ matrix.laravel }}" --no-interaction --no-update
          composer update --${{ matrix.dependency-version }} --prefer-dist --no-interaction

      - name: Execute tests
        run: vendor/bin/pest
</file>

<file path="src/Stubs/github/CONTRIBUTING.md.stub">
# Contributing to {{ plugin_name }}

Thank you for considering contributing to {{ plugin_name }}!

## Pull Requests

1. Fork the repository
2. Create a new branch for your feature
3. Write tests for your changes
4. Ensure all tests pass
5. Submit a pull request

## Coding Standards

- Follow PSR-12 coding standards
- Run `composer format` before committing
- Write tests for new features
- Ensure PHPStan passes with level 5

## Running Tests

```bash
composer test
```

## Code Style

```bash
composer format
```

## Static Analysis

```bash
composer analyse
```
</file>

<file path="src/Stubs/github/dependabot.yml.stub">
version: 2
updates:
  - package-ecosystem: "composer"
    directory: "/"
    schedule:
      interval: "weekly"
    open-pull-requests-limit: 10

  - package-ecosystem: "github-actions"
    directory: "/"
    schedule:
      interval: "weekly"
</file>

<file path="src/Stubs/github/FUNDING.yml.stub">
github: {{ github_username }}
</file>

<file path="src/Stubs/github/SECURITY.md.stub">
# Security Policy

## Reporting a Vulnerability

If you discover a security vulnerability within {{ plugin_name }}, please send an email to {{ author_email }}. All security vulnerabilities will be promptly addressed.

Please do not publicly disclose the issue until it has been addressed by the team.
</file>

<file path="src/Stubs/js/app.stub">
/**
 * {{ plugin_name }} Plugin for Vue.js
 *
 * This plugin can be registered in your main Laravilt application.
 *
 * Example usage in app.ts:
 *
 * import {{ plugin_name }}Plugin from '@/plugins/{{ kebab_name }}';
 *
 * app.use({{ plugin_name }}Plugin, {
 *     // Plugin options
 * });
 */

export default {
    install(app, options = {}) {
        // Plugin installation logic
        console.log('{{ plugin_name }} plugin installed', options);

        // Register global components
        // app.component('{{ plugin_name }}Component', ComponentName);

        // Provide global properties
        // app.config.globalProperties.${{ kebab_name }} = {};

        // Add global methods
        // app.mixin({});
    }
};
</file>

<file path="src/Stubs/routes/api.stub">
<?php

use Illuminate\Support\Facades\Route;

/*
|--------------------------------------------------------------------------
| {{ name }} API Routes
|--------------------------------------------------------------------------
|
| Here is where you can register API routes for your plugin. These
| routes are loaded by the ServiceProvider within a group which
| is assigned the "api" middleware group.
|
*/

Route::middleware(['api'])->prefix('api/{{ kebab_name }}')->group(function () {
    // Add your API routes here
    // Example:
    // Route::get('/items', [ItemController::class, 'index']);
    // Route::post('/items', [ItemController::class, 'store']);
});
</file>

<file path="src/Stubs/routes/web.stub">
<?php

use Illuminate\Support\Facades\Route;

/*
|--------------------------------------------------------------------------
| {{ name }} Web Routes
|--------------------------------------------------------------------------
|
| Here is where you can register web routes for your plugin. These
| routes are loaded by the ServiceProvider within a group which
| contains the "web" middleware group.
|
*/

Route::middleware(['web'])->group(function () {
    // Add your web routes here
    // Example:
    // Route::get('/{{ kebab_name }}', function () {
    //     return view('{{ kebab_name }}::index');
    // });
});
</file>

<file path="src/Stubs/.gitignore.stub">
.idea
.phpunit.cache
.phpunit.result.cache
.DS_Store
Thumbs.db
/vendor/
/node_modules/
/.vscode/
composer.lock
package-lock.json
*.log
.env
.env.backup
.env.production
/dist/
/build/
</file>

<file path="src/Stubs/bug.yml.stub">
name: Bug Report
description: Report an Issue or Bug with the Package
title: "[Bug]: "
labels: ["bug"]
body:
  - type: markdown
    attributes:
      value: |
        We're sorry to hear you have a problem. Can you help us solve it by providing the following details.
  - type: textarea
    id: what-happened
    attributes:
      label: What happened?
      description: What did you expect to happen?
      placeholder: I cannot currently do X thing because when I do, it breaks X thing.
    validations:
      required: true
  - type: textarea
    id: how-to-reproduce
    attributes:
      label: How to reproduce the bug
      description: How did this occur, please add any config values used and provide a set of reliable steps if possible.
      placeholder: When I do X I see Y.
    validations:
      required: true
  - type: input
    id: package-version
    attributes:
      label: Package Version
      description: What version of our Package are you running? Please be as specific as possible
      placeholder: 2.0.0
    validations:
      required: true
  - type: input
    id: php-version
    attributes:
      label: PHP Version
      description: What version of PHP are you running? Please be as specific as possible
      placeholder: 8.2.0
    validations:
      required: true
  - type: input
    id: laravel-version
    attributes:
      label: Laravel Version
      description: What version of Laravel are you running? Please be as specific as possible
      placeholder: 9.0.0
    validations:
      required: true
  - type: dropdown
    id: operating-systems
    attributes:
      label: Which operating systems does with happen with?
      description: You may select more than one.
      multiple: true
      options:
        - macOS
        - Windows
        - Linux
  - type: textarea
    id: notes
    attributes:
      label: Notes
      description: Use this field to provide any other notes that you feel might be relevant to the issue.
    validations:
      required: false
</file>

<file path="src/Stubs/CHANGELOG.md.stub">
# Changelog

All notable changes to `{{ plugin_name }}` will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

## [Unreleased]

### Added
- Initial release

### Changed

### Deprecated

### Removed

### Fixed

### Security
</file>

<file path="src/Stubs/CODE_OF_CONDUCT.md.stub">
# Contributor Covenant Code of Conduct

## Our Pledge

We as members, contributors, and leaders pledge to make participation in our
community a harassment-free experience for everyone, regardless of age, body
size, visible or invisible disability, ethnicity, sex characteristics, gender
identity and expression, level of experience, education, socio-economic status,
nationality, personal appearance, race, religion, or sexual identity
and orientation.

We pledge to act and interact in ways that contribute to an open, welcoming,
diverse, inclusive, and healthy community.

## Our Standards

Examples of behavior that contributes to a positive environment for our
community include:

* Demonstrating empathy and kindness toward other people
* Being respectful of differing opinions, viewpoints, and experiences
* Giving and gracefully accepting constructive feedback
* Accepting responsibility and apologizing to those affected by our mistakes,
  and learning from the experience
* Focusing on what is best not just for us as individuals, but for the
  overall community

Examples of unacceptable behavior include:

* The use of sexualized language or imagery, and sexual attention or
  advances of any kind
* Trolling, insulting or derogatory comments, and personal or political attacks
* Public or private harassment
* Publishing others' private information, such as a physical or email
  address, without their explicit permission
* Other conduct which could reasonably be considered inappropriate in a
  professional setting

## Enforcement Responsibilities

Community leaders are responsible for clarifying and enforcing our standards of
acceptable behavior and will take appropriate and fair corrective action in
response to any behavior that they deem inappropriate, threatening, offensive,
or harmful.

## Scope

This Code of Conduct applies within all community spaces, and also applies when
an individual is officially representing the community in public spaces.

## Enforcement

Instances of abusive, harassing, or otherwise unacceptable behavior may be
reported to the community leaders responsible for enforcement.

All complaints will be reviewed and investigated promptly and fairly.

All community leaders are obligated to respect the privacy and security of the
reporter of any incident.

## Attribution

This Code of Conduct is adapted from the [Contributor Covenant](https://www.contributor-covenant.org),
version 2.0, available at https://www.contributor-covenant.org/version/2/0/code_of_conduct.html.
</file>

<file path="src/Stubs/config.stub">
<?php

return [
    /*
    |--------------------------------------------------------------------------
    | Plugin Settings
    |--------------------------------------------------------------------------
    |
    | Configure your plugin settings here.
    |
    */

    'enabled' => env('{{ env_prefix }}_ENABLED', true),

    // Add your configuration options here
];
</file>

<file path="src/Stubs/config.yml.stub">
blank_issues_enabled: false
contact_links:
  - name: Ask a question
    url: https://github.com/{{ vendor }}/{{ package }}/discussions/new?category=q-a
    about: Ask the community for help
  - name: Request a feature
    url: https://github.com/{{ vendor }}/{{ package }}/discussions/new?category=ideas
    about: Share ideas for new features
  - name: Report a security issue
    url: https://github.com/{{ vendor }}/{{ package }}/security/policy
    about: Learn how to notify us for sensitive bugs
</file>

<file path="src/Stubs/DebugTest.stub">
<?php

it('will not use debugging functions', function () {
    expect(['dd', 'dump', 'ray'])->each->not->toBeUsed();
});
</file>

<file path="src/Stubs/install-command.stub">
<?php

namespace {{ namespace }}\Commands;

use Illuminate\Console\Command;
use Illuminate\Support\Facades\Artisan;

class {{ class }} extends Command
{
    /**
     * The name and signature of the console command.
     */
    protected $signature = '{{ command_name }}
                            {--force : Overwrite existing files}{{ signature_options }}';

    /**
     * The console command description.
     */
    protected $description = 'Install {{ plugin_name }} plugin';

    /**
     * Execute the console command.
     */
    public function handle(): int
    {
        $this->info('Installing {{ name }} plugin...');
        $this->newLine();

        // Publish config
        $this->publishConfig();

{{ publish_assets_call }}{{ run_migrations_block }}{{ run_seeders_block }}{{ build_assets_block }}
        $this->newLine();
        $this->info('✅ {{ name }} plugin installed successfully!');
        $this->newLine();

        return self::SUCCESS;
    }

    /**
     * Publish configuration file.
     */
    protected function publishConfig(): void
    {
        $this->info('Publishing configuration...');

        $params = ['--tag' => '{{ config }}-config'];

        if ($this->option('force')) {
            $params['--force'] = true;
        }

        Artisan::call('vendor:publish', $params, $this->output);
    }
{{ publish_assets_method }}{{ run_migrations_method }}{{ run_seeders_method }}{{ build_assets_method }}
}
</file>

<file path="src/Stubs/lang.stub">
<?php

return [
    /*
    |--------------------------------------------------------------------------
    | {{ package_name }} Language Lines
    |--------------------------------------------------------------------------
    |
    | The following language lines are used by the {{ package_name }} plugin.
    | You are free to modify these language lines according to your
    | application's requirements.
    |
    */

    // Add your translation messages here
];
</file>

<file path="src/Stubs/LICENSE.md.stub">
MIT License

Copyright (c) {{ year }} {{ author }}

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</file>

<file path="src/Stubs/messages.php.stub">
<?php

return [
    // Add your translation messages here
];
</file>

<file path="src/Stubs/migration.stub">
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('{{ table }}', function (Blueprint $table) {
            $table->id();
            $table->string('name');
            $table->timestamps();
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('{{ table }}');
    }
};
</file>

<file path="src/Stubs/model.stub">
<?php

namespace {{ namespace }};

use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Factories\HasFactory;

class {{ class }} extends Model
{
    use HasFactory;

    protected $fillable = [
        'name',
    ];

    protected $casts = [
        'created_at' => 'datetime',
        'updated_at' => 'datetime',
    ];
}
</file>

<file path="src/Stubs/page.stub">
<?php

namespace {{ namespace }}\Pages;

use Filament\Pages\Page;

class {{ class }} extends Page
{
    protected static ?string $navigationIcon = 'heroicon-o-document-text';

    protected static string $view = '{{ view }}';
}
</file>

<file path="src/Stubs/Pest.php.stub">
<?php

use {{ namespace }}\Tests\TestCase;

uses(TestCase::class)->in(__DIR__);
</file>

<file path="src/Stubs/Pest.stub">
<?php

use {{ namespace }}\Tests\TestCase;

uses(TestCase::class)->in(__DIR__);
</file>

<file path="src/Stubs/phpstan.neon.stub">
includes:
    - phpstan-baseline.neon

parameters:
    level: 5
    paths:
        - src
    tmpDir: build/phpstan
    checkOctaneCompatibility: true
    checkModelProperties: true
    checkMissingIterableValueType: false
</file>

<file path="src/Stubs/phpunit.xml.stub">
<?xml version="1.0" encoding="UTF-8"?>
<phpunit xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:noNamespaceSchemaLocation="https://schema.phpunit.de/11.0/phpunit.xsd"
         bootstrap="vendor/autoload.php"
         colors="true"
>
    <testsuites>
        <testsuite name="Test Suite">
            <directory suffix="Test.php">./tests</directory>
        </testsuite>
    </testsuites>
    <coverage>
        <report>
            <html outputDirectory="build/coverage"/>
            <text outputFile="build/coverage.txt"/>
            <clover outputFile="build/logs/clover.xml"/>
        </report>
    </coverage>
    <source>
        <include>
            <directory suffix=".php">./src</directory>
        </include>
    </source>
</phpunit>
</file>

<file path="src/Stubs/pint.json.stub">
{
    "preset": "laravel",
    "rules": {
        "simplified_null_return": true,
        "braces": false,
        "new_with_braces": {
            "anonymous_class": false,
            "named_class": false
        }
    }
}
</file>

<file path="src/Stubs/resource.stub">
<?php

namespace {{ namespace }}\Resources;

use Filament\Forms;
use Filament\Forms\Form;
use Filament\Resources\Resource;
use Filament\Tables;
use Filament\Tables\Table;
use {{ namespace }}\Resources\{{ class }}Resource\Pages;
use {{ model_namespace }}\{{ model }};

class {{ class }}Resource extends Resource
{
    protected static ?string $model = {{ model }}::class;

    protected static ?string $navigationIcon = 'heroicon-o-rectangle-stack';

    public static function form(Form $form): Form
    {
        return $form
            ->schema([
                Forms\Components\TextInput::make('name')
                    ->required()
                    ->maxLength(255),
            ]);
    }

    public static function table(Table $table): Table
    {
        return $table
            ->columns([
                Tables\Columns\TextColumn::make('name')
                    ->searchable(),
                Tables\Columns\TextColumn::make('created_at')
                    ->dateTime()
                    ->sortable(),
            ])
            ->filters([
                //
            ])
            ->actions([
                Tables\Actions\EditAction::make(),
            ])
            ->bulkActions([
                Tables\Actions\BulkActionGroup::make([
                    Tables\Actions\DeleteBulkAction::make(),
                ]),
            ]);
    }

    public static function getRelations(): array
    {
        return [
            //
        ];
    }

    public static function getPages(): array
    {
        return [
            'index' => Pages\List{{ class }}::route('/'),
            'create' => Pages\Create{{ class }}::route('/create'),
            'edit' => Pages\Edit{{ class }}::route('/{record}/edit'),
        ];
    }
}
</file>

<file path="src/Stubs/service-provider.stub">
<?php

namespace {{ namespace }};

use Illuminate\Support\ServiceProvider;

class {{ class }} extends ServiceProvider
{
    /**
     * Register services.
     */
    public function register(): void
    {
        // Merge config
        $this->mergeConfigFrom(
            __DIR__ . '/../config/{{ config }}.php',
            '{{ config }}'
        );

        // Register any services, bindings, or singletons here
    }

    /**
     * Bootstrap services.
     */
    public function boot(): void
    {
{{ views_loading }}
        // Load translations
        $this->loadTranslationsFrom(__DIR__ . '/../resources/lang', '{{ id }}');

{{ migrations_loading }}{{ routes_loading }}

        if ($this->app->runningInConsole()) {
            // Publish config
            $this->publishes([
                __DIR__ . '/../config/{{ config }}.php' => config_path('{{ config }}.php'),
            ], '{{ config }}-config');

{{ assets_publishes }}{{ views_publishes }}{{ migrations_publishes }}
            // Register commands
            $this->commands([
                Commands\{{ install_command_class }}::class,
            ]);
        }
    }
}
</file>

<file path="src/Stubs/testbench.yaml.stub">
providers:
  - {{ namespace }}\{{ service_provider }}

workbench:
  welcome: false
  discovers:
    web: true
    api: true
    commands: true
    components: true
</file>

<file path="src/Stubs/TestCase.stub">
<?php

namespace {{ namespace }}\Tests;

{{ use_refresh_database }}use Orchestra\Testbench\TestCase as Orchestra;

class TestCase extends Orchestra
{
{{ use_refresh_database_trait }}
    protected function setUp(): void
    {
        parent::setUp();

{{ load_migrations }}        // Additional setup if needed
    }

    protected function getPackageProviders($app): array
    {
        return [
            \{{ namespace }}\{{ service_provider }}::class,
        ];
    }

    protected function getEnvironmentSetUp($app): void
    {
        // Setup environment for testing
        config()->set('database.default', 'testing');
{{ database_config }}    }
}
</file>

<file path="src/Stubs/vite.plugin.stub">
import { resolve } from 'path';

export default function {{ plugin_name }}Plugin() {
    const pluginPath = resolve(__dirname);

    return {
        name: '{{ kebab_name }}-plugin',
        config: () => ({
            build: {
                rollupOptions: {
                    input: {
                        '{{ kebab_name }}': resolve(pluginPath, 'resources/js/app.js'),
                    },
                    output: {
                        entryFileNames: 'js/[name].js',
                        chunkFileNames: 'js/[name].js',
                        assetFileNames: (assetInfo) => {
                            if (assetInfo.name.endsWith('.css')) {
                                return 'css/[name][extname]';
                            }
                            return 'assets/[name][extname]';
                        },
                    },
                },
                outDir: resolve(pluginPath, 'dist'),
                emptyOutDir: true,
            },
        }),
    };
}
</file>

<file path="src/Stubs/widget.stub">
<?php

namespace {{ namespace }}\Widgets;

use Filament\Widgets\Widget;

class {{ class }} extends Widget
{
    protected static string $view = '{{ view }}';

    protected int | string | array $columnSpan = 'full';

    protected static ?int $sort = null;
}
</file>

<file path="src/Support/PluginManager.php">
<?php

namespace Laravilt\Plugins\Support;

use Illuminate\Contracts\Foundation\Application;
use Illuminate\Support\Collection;
use Laravilt\Plugins\Contracts\Plugin;
use Laravilt\Plugins\Contracts\PluginManager as PluginManagerContract;

class PluginManager implements PluginManagerContract
{
    protected Application $app;

    /**
     * Registered plugins.
     *
     * @var Collection<string, Plugin>
     */
    protected Collection $plugins;

    /**
     * Booted plugins.
     *
     * @var Collection<string>
     */
    protected Collection $booted;

    public function __construct(Application $app)
    {
        $this->app = $app;
        $this->plugins = collect();
        $this->booted = collect();
    }

    /**
     * Register a plugin.
     */
    public function register(Plugin $plugin): void
    {
        $id = $plugin->getId();

        if ($this->plugins->has($id)) {
            throw new \RuntimeException("Plugin '{$id}' is already registered.");
        }

        // Check dependencies
        if (! $plugin->dependenciesSatisfied()) {
            $dependencies = implode(', ', $plugin->getDependencies());
            throw new \RuntimeException(
                "Plugin '{$id}' dependencies not satisfied: {$dependencies}"
            );
        }

        $this->plugins->put($id, $plugin);
    }

    /**
     * Boot a plugin.
     */
    public function boot(string $id): void
    {
        if ($this->booted->contains($id)) {
            return;
        }

        $plugin = $this->get($id);

        if (! $plugin->isEnabled()) {
            return;
        }

        // Boot dependencies first
        foreach ($plugin->getDependencies() as $dependency) {
            $this->boot($dependency);
        }

        $this->booted->push($id);
    }

    /**
     * Boot all plugins.
     */
    public function bootAll(): void
    {
        foreach ($this->plugins->keys() as $id) {
            $this->boot($id);
        }
    }

    /**
     * Get a plugin by ID.
     */
    public function get(string $id): Plugin
    {
        if (! $this->has($id)) {
            throw new \RuntimeException("Plugin '{$id}' is not registered.");
        }

        return $this->plugins->get($id);
    }

    /**
     * Check if a plugin is registered.
     */
    public function has(string $id): bool
    {
        return $this->plugins->has($id);
    }

    /**
     * Get all plugins.
     *
     * @return Collection<string, Plugin>
     */
    public function all(): Collection
    {
        return $this->plugins;
    }

    /**
     * Get enabled plugins.
     *
     * @return Collection<string, Plugin>
     */
    public function enabled(): Collection
    {
        return $this->plugins->filter(fn (Plugin $plugin) => $plugin->isEnabled());
    }

    /**
     * Discover plugins.
     */
    public function discover(): void
    {
        $discovery = new PluginDiscovery($this->app);
        $plugins = $discovery->discover();

        foreach ($plugins as $plugin) {
            $this->register($plugin);
        }
    }

    /**
     * Get plugin manifest.
     */
    public function getManifest(): PluginManifest
    {
        return new PluginManifest($this->plugins);
    }
}
</file>

<file path="src/Testing/PluginTestCase.php">
<?php

namespace Laravilt\Plugins\Testing;

use Laravilt\Plugins\PluginsServiceProvider;
use Orchestra\Testbench\TestCase as Orchestra;

abstract class PluginTestCase extends Orchestra
{
    protected function setUp(): void
    {
        parent::setUp();

        $this->setUpDatabase();
        $this->setUpPluginAssets();
    }

    protected function getPackageProviders($app): array
    {
        return [
            PluginsServiceProvider::class,
            $this->getPluginServiceProvider(),
        ];
    }

    /**
     * Get the plugin service provider class.
     */
    abstract protected function getPluginServiceProvider(): string;

    /**
     * Setup the test database.
     */
    protected function setUpDatabase(): void
    {
        $migrationsPath = $this->getPluginMigrationsPath();

        if ($migrationsPath && is_dir($migrationsPath)) {
            $this->loadMigrationsFrom($migrationsPath);
        }
    }

    /**
     * Get the plugin migrations path.
     */
    protected function getPluginMigrationsPath(): ?string
    {
        return null;
    }

    /**
     * Setup plugin assets for testing.
     */
    protected function setUpPluginAssets(): void
    {
        // Publish plugin assets if needed
    }

    /**
     * Assert that a plugin is registered.
     */
    protected function assertPluginRegistered(string $pluginId): void
    {
        $manager = app('laravilt.plugins');

        $this->assertTrue(
            $manager->has($pluginId),
            "Plugin '{$pluginId}' is not registered."
        );
    }

    /**
     * Assert that a plugin is enabled.
     */
    protected function assertPluginEnabled(string $pluginId): void
    {
        $manager = app('laravilt.plugins');
        $plugin = $manager->get($pluginId);

        $this->assertTrue(
            $plugin->isEnabled(),
            "Plugin '{$pluginId}' is not enabled."
        );
    }
}
</file>

<file path="src/BasePlugin.php">
<?php

namespace Laravilt\Plugins;

use Filament\Panel;
use Laravilt\Plugins\Concerns\HasAssets;
use Laravilt\Plugins\Concerns\HasCommands;
use Laravilt\Plugins\Concerns\HasComponents;
use Laravilt\Plugins\Concerns\HasMigrations;
use Laravilt\Plugins\Concerns\HasTranslations;
use Laravilt\Plugins\Concerns\HasViews;
use Laravilt\Plugins\Contracts\Plugin;
use Spatie\LaravelPackageTools\Package;
use Spatie\LaravelPackageTools\PackageServiceProvider;

abstract class BasePlugin extends PackageServiceProvider implements Plugin
{
    use HasAssets;
    use HasCommands;
    use HasComponents;
    use HasMigrations;
    use HasTranslations;
    use HasViews;

    /**
     * The plugin ID.
     */
    protected static string $id;

    /**
     * The plugin name.
     */
    protected static string $name;

    /**
     * The plugin version.
     */
    protected static string $version = '1.0.0';

    /**
     * The plugin description.
     */
    protected static string $description = '';

    /**
     * The plugin author.
     */
    protected static string $author = '';

    /**
     * Plugin dependencies.
     *
     * @var array<string>
     */
    protected static array $dependencies = [];

    /**
     * Whether the plugin is enabled.
     */
    protected bool $enabled = true;

    /**
     * Get the plugin ID.
     */
    public function getId(): string
    {
        return static::$id ?? static::$name;
    }

    /**
     * Get the plugin name.
     */
    public function getName(): string
    {
        return static::$name;
    }

    /**
     * Get the plugin version.
     */
    public function getVersion(): string
    {
        return static::$version;
    }

    /**
     * Get the plugin description.
     */
    public function getDescription(): string
    {
        return static::$description;
    }

    /**
     * Get the plugin author.
     */
    public function getAuthor(): string
    {
        return static::$author;
    }

    /**
     * Get plugin dependencies.
     */
    public function getDependencies(): array
    {
        return static::$dependencies;
    }

    /**
     * Check if dependencies are satisfied.
     */
    public function dependenciesSatisfied(): bool
    {
        $manager = app('laravilt.plugins');

        foreach ($this->getDependencies() as $dependency) {
            if (! $manager->has($dependency)) {
                return false;
            }
        }

        return true;
    }

    /**
     * Check if the plugin is enabled.
     */
    public function isEnabled(): bool
    {
        return $this->enabled;
    }

    /**
     * Enable the plugin.
     */
    public function enable(): static
    {
        $this->enabled = true;

        return $this;
    }

    /**
     * Disable the plugin.
     */
    public function disable(): static
    {
        $this->enabled = false;

        return $this;
    }

    /**
     * Register the plugin with a panel.
     */
    abstract public function register(Panel $panel): void;

    /**
     * Boot the plugin for a panel.
     */
    public function boot(Panel $panel): void
    {
        // Can be overridden by plugin implementations
    }

    /**
     * Create a new instance of the plugin.
     */
    public static function make(): static
    {
        return app(static::class);
    }

    /**
     * Get the default instance of the plugin.
     */
    public static function get(): static
    {
        return filament(static::$id ?? static::$name);
    }

    /**
     * Configure the package.
     */
    abstract public function configurePackage(Package $package): void;
}
</file>

<file path="src/PluginProvider.php">
<?php

namespace Laravilt\Plugins;

use Filament\Panel;
use Illuminate\Support\ServiceProvider;
use Laravilt\Plugins\Concerns\HasAssets;
use Laravilt\Plugins\Concerns\HasCommands;
use Laravilt\Plugins\Concerns\HasComponents;
use Laravilt\Plugins\Concerns\HasMigrations;
use Laravilt\Plugins\Concerns\HasTranslations;
use Laravilt\Plugins\Concerns\HasViews;
use Laravilt\Plugins\Contracts\Plugin;

abstract class PluginProvider extends ServiceProvider implements Plugin
{
    use HasAssets;
    use HasCommands;
    use HasComponents;
    use HasMigrations;
    use HasTranslations;
    use HasViews;

    /**
     * The plugin ID.
     */
    protected static string $id;

    /**
     * The plugin name.
     */
    protected static string $name;

    /**
     * The plugin version.
     */
    protected static string $version = '1.0.0';

    /**
     * The plugin description.
     */
    protected static string $description = '';

    /**
     * The plugin author.
     */
    protected static string $author = '';

    /**
     * Plugin dependencies.
     *
     * @var array<string>
     */
    protected static array $dependencies = [];

    /**
     * Whether the plugin is enabled.
     */
    protected bool $enabled = true;

    /**
     * Get the plugin ID.
     */
    public function getId(): string
    {
        return static::$id ?? static::$name;
    }

    /**
     * Get the plugin name.
     */
    public function getName(): string
    {
        return static::$name;
    }

    /**
     * Get the plugin version.
     */
    public function getVersion(): string
    {
        return static::$version;
    }

    /**
     * Get the plugin description.
     */
    public function getDescription(): string
    {
        return static::$description;
    }

    /**
     * Get the plugin author.
     */
    public function getAuthor(): string
    {
        return static::$author;
    }

    /**
     * Get plugin dependencies.
     */
    public function getDependencies(): array
    {
        return static::$dependencies;
    }

    /**
     * Check if dependencies are satisfied.
     */
    public function dependenciesSatisfied(): bool
    {
        $manager = app('laravilt.plugins');

        foreach ($this->getDependencies() as $dependency) {
            if (! $manager->has($dependency)) {
                return false;
            }
        }

        return true;
    }

    /**
     * Check if the plugin is enabled.
     */
    public function isEnabled(): bool
    {
        return $this->enabled;
    }

    /**
     * Enable the plugin.
     */
    public function enable(): static
    {
        $this->enabled = true;

        return $this;
    }

    /**
     * Disable the plugin.
     */
    public function disable(): static
    {
        $this->enabled = false;

        return $this;
    }

    /**
     * Register the plugin with a panel.
     */
    abstract public function register(Panel $panel): void;

    /**
     * Boot the plugin for a panel.
     */
    public function boot(Panel $panel): void
    {
        // Can be overridden by plugin implementations
    }

    /**
     * Create a new instance of the plugin.
     */
    public static function make(): static
    {
        return app(static::class);
    }

    /**
     * Get the default instance of the plugin.
     */
    public static function get(): static
    {
        /** @var \Filament\FilamentManager $filament */
        $filament = app('filament');

        return $filament->getPlugin(static::$id ?? static::$name);
    }
}
</file>

<file path="tests/Feature/PluginGeneratorTest.php">
<?php

use Illuminate\Filesystem\Filesystem;
use Laravilt\Plugins\Services\PluginFeatureFactory;
use Laravilt\Plugins\Services\PluginGenerator;

beforeEach(function () {
    $this->files = Mockery::mock(Filesystem::class);
    $this->factory = Mockery::mock(PluginFeatureFactory::class);
    $this->generator = new PluginGenerator($this->files, $this->factory);
});

afterEach(function () {
    Mockery::close();
});

test('can create directory structure', function () {
    $basePath = '/path/to/plugin';
    $config = ['test' => true];
    $directories = ['src', 'tests', 'config'];

    $this->factory->shouldReceive('getDirectories')
        ->once()
        ->with($config)
        ->andReturn($directories);

    $this->files->shouldReceive('makeDirectory')
        ->once()
        ->with("{$basePath}/src", 0755, true, true);

    $this->files->shouldReceive('makeDirectory')
        ->once()
        ->with("{$basePath}/tests", 0755, true, true);

    $this->files->shouldReceive('makeDirectory')
        ->once()
        ->with("{$basePath}/config", 0755, true, true);

    $this->generator->createDirectoryStructure($basePath, $config);
});

test('can generate all files', function () {
    $config = ['test' => true];

    $this->factory->shouldReceive('generateAll')
        ->once()
        ->with($config);

    $this->generator->generateAllFiles($config);
});
</file>

<file path="tests/Unit/Features/AbstractFeatureTest.php">
<?php

use Laravilt\Plugins\Features\AbstractFeature;
use Laravilt\Plugins\Services\Generation\StubProcessor;

beforeEach(function () {
    $this->processor = Mockery::mock(StubProcessor::class);
    $this->feature = new class($this->processor) extends AbstractFeature
    {
        public function getName(): string
        {
            return 'test-feature';
        }

        public function shouldGenerate(array $config): bool
        {
            return true;
        }

        public function generate(array $config): void
        {
            //
        }
    };
});

afterEach(function () {
    Mockery::close();
});

test('has default priority of 50', function () {
    expect($this->feature->getPriority())->toBe(50);
});

test('returns empty directories by default', function () {
    expect($this->feature->getDirectories([]))->toBe([]);
});

test('can be extended with custom priority', function () {
    $customFeature = new class($this->processor) extends AbstractFeature
    {
        public function getName(): string
        {
            return 'custom';
        }

        public function shouldGenerate(array $config): bool
        {
            return true;
        }

        public function generate(array $config): void
        {
            //
        }

        public function getPriority(): int
        {
            return 100;
        }
    };

    expect($customFeature->getPriority())->toBe(100);
});

test('can be extended with custom directories', function () {
    $customFeature = new class($this->processor) extends AbstractFeature
    {
        public function getName(): string
        {
            return 'custom';
        }

        public function shouldGenerate(array $config): bool
        {
            return true;
        }

        public function generate(array $config): void
        {
            //
        }

        public function getDirectories(array $config): array
        {
            return ['src', 'tests'];
        }
    };

    expect($customFeature->getDirectories([]))->toBe(['src', 'tests']);
});
</file>

<file path="tests/Unit/Features/ComposerJsonFeatureTest.php">
<?php

use Laravilt\Plugins\Features\ComposerJsonFeature;
use Laravilt\Plugins\Services\Generation\StubProcessor;

beforeEach(function () {
    $this->processor = Mockery::mock(StubProcessor::class);
    $this->feature = new ComposerJsonFeature($this->processor);
});

afterEach(function () {
    Mockery::close();
});

test('has correct name', function () {
    expect($this->feature->getName())->toBe('composer-json');
});

test('should always generate', function () {
    expect($this->feature->shouldGenerate([]))->toBeTrue()
        ->and($this->feature->shouldGenerate(['any' => 'config']))->toBeTrue();
});

test('has high priority', function () {
    expect($this->feature->getPriority())->toBe(1);
});

test('generates composer json file with correct replacements', function () {
    $config = [
        'base_path' => '/path/to/plugin',
        'vendor_lower' => 'acme',
        'kebab_name' => 'blog-plugin',
        'studly_name' => 'BlogPlugin',
        'author' => 'John Doe',
        'email' => 'john@example.com',
        'license' => 'MIT',
        'namespace' => 'Acme\\BlogPlugin',
    ];

    $this->processor->shouldReceive('generateFile')
        ->once()
        ->with(
            '/path/to/plugin/composer.json',
            'composer.json',
            Mockery::on(function ($replacements) {
                return $replacements['vendor'] === 'acme'
                    && $replacements['package'] === 'blog-plugin'
                    && $replacements['author'] === 'John Doe'
                    && $replacements['email'] === 'john@example.com'
                    && $replacements['license'] === 'MIT'
                    && $replacements['namespace'] === 'Acme\\\\BlogPlugin'
                    && $replacements['class'] === 'BlogPluginPlugin'
                    && $replacements['service_provider'] === 'BlogPluginServiceProvider';
            })
        );

    $this->feature->generate($config);
});

test('uses plugin description from config if provided', function () {
    $config = [
        'base_path' => '/path/to/plugin',
        'vendor_lower' => 'acme',
        'kebab_name' => 'blog-plugin',
        'studly_name' => 'BlogPlugin',
        'author' => 'John Doe',
        'email' => 'john@example.com',
        'license' => 'MIT',
        'namespace' => 'Acme\\BlogPlugin',
        'plugin_description' => 'A custom description',
    ];

    $this->processor->shouldReceive('generateFile')
        ->once()
        ->with(
            Mockery::any(),
            Mockery::any(),
            Mockery::on(fn ($replacements) => $replacements['description'] === 'A custom description')
        );

    $this->feature->generate($config);
});

test('uses default description if not provided', function () {
    $config = [
        'base_path' => '/path/to/plugin',
        'vendor_lower' => 'acme',
        'kebab_name' => 'blog-plugin',
        'studly_name' => 'BlogPlugin',
        'author' => 'John Doe',
        'email' => 'john@example.com',
        'license' => 'MIT',
        'namespace' => 'Acme\\BlogPlugin',
    ];

    $this->processor->shouldReceive('generateFile')
        ->once()
        ->with(
            Mockery::any(),
            Mockery::any(),
            Mockery::on(fn ($replacements) => $replacements['description'] === 'BlogPlugin plugin for Laravilt')
        );

    $this->feature->generate($config);
});

test('uses author email from author_email config if provided', function () {
    $config = [
        'base_path' => '/path/to/plugin',
        'vendor_lower' => 'acme',
        'kebab_name' => 'blog-plugin',
        'studly_name' => 'BlogPlugin',
        'author' => 'John Doe',
        'email' => 'default@example.com',
        'author_email' => 'custom@example.com',
        'license' => 'MIT',
        'namespace' => 'Acme\\BlogPlugin',
    ];

    $this->processor->shouldReceive('generateFile')
        ->once()
        ->with(
            Mockery::any(),
            Mockery::any(),
            Mockery::on(fn ($replacements) => $replacements['email'] === 'custom@example.com')
        );

    $this->feature->generate($config);
});
</file>

<file path="tests/Unit/Mcp/ListComponentTypesToolTest.php">
<?php

use Laravel\Mcp\Request;
use Laravel\Mcp\Response;
use Laravilt\Plugins\Mcp\Tools\ListComponentTypesTool;

beforeEach(function () {
    $this->tool = new ListComponentTypesTool;
});

test('tool extends base tool class', function () {
    expect($this->tool)->toBeInstanceOf(\Laravel\Mcp\Server\Tool::class);
});

test('has description property', function () {
    $reflection = new ReflectionClass($this->tool);
    $property = $reflection->getProperty('description');
    $description = $property->getValue($this->tool);

    expect($description)->toBeString()
        ->and($description)->toContain('component types');
});

test('has handle method', function () {
    $reflection = new ReflectionClass($this->tool);
    expect($reflection->hasMethod('handle'))->toBeTrue();
});

test('has schema method', function () {
    $reflection = new ReflectionClass($this->tool);
    expect($reflection->hasMethod('schema'))->toBeTrue();
});

test('handle method returns response', function () {
    $request = Mockery::mock(Request::class);
    $response = $this->tool->handle($request);

    expect($response)->toBeInstanceOf(Response::class);
});

test('schema returns empty array', function () {
    $schema = Mockery::mock(\Illuminate\JsonSchema\JsonSchema::class);
    $result = $this->tool->schema($schema);

    expect($result)->toBe([]);
});

afterEach(function () {
    Mockery::close();
});
</file>

<file path="tests/Unit/PluginFeatureFactoryTest.php">
<?php

use Laravilt\Plugins\Contracts\PluginFeatureInterface;
use Laravilt\Plugins\Services\PluginFeatureFactory;

beforeEach(function () {
    $this->factory = new PluginFeatureFactory;
});

test('can register a feature', function () {
    $feature = Mockery::mock(PluginFeatureInterface::class);
    $feature->shouldReceive('getName')->andReturn('test-feature');

    $this->factory->register($feature);

    expect($this->factory->getFeatures())->toHaveCount(1);
});

test('can register multiple features', function () {
    $feature1 = Mockery::mock(PluginFeatureInterface::class);
    $feature1->shouldReceive('getName')->andReturn('feature-1');
    $feature1->shouldReceive('getPriority')->andReturn(10);

    $feature2 = Mockery::mock(PluginFeatureInterface::class);
    $feature2->shouldReceive('getName')->andReturn('feature-2');
    $feature2->shouldReceive('getPriority')->andReturn(20);

    $this->factory->registerMany([$feature1, $feature2]);

    expect($this->factory->getFeatures())->toHaveCount(2);
});

test('sorts features by priority', function () {
    $lowPriority = Mockery::mock(PluginFeatureInterface::class);
    $lowPriority->shouldReceive('getName')->andReturn('low');
    $lowPriority->shouldReceive('getPriority')->andReturn(50);

    $highPriority = Mockery::mock(PluginFeatureInterface::class);
    $highPriority->shouldReceive('getName')->andReturn('high');
    $highPriority->shouldReceive('getPriority')->andReturn(10);

    $midPriority = Mockery::mock(PluginFeatureInterface::class);
    $midPriority->shouldReceive('getName')->andReturn('mid');
    $midPriority->shouldReceive('getPriority')->andReturn(30);

    $this->factory->register($lowPriority);
    $this->factory->register($highPriority);
    $this->factory->register($midPriority);

    $features = $this->factory->getFeatures();

    expect($features[0]->getName())->toBe('high')
        ->and($features[1]->getName())->toBe('mid')
        ->and($features[2]->getName())->toBe('low');
});

test('can get directories from all features', function () {
    $feature1 = Mockery::mock(PluginFeatureInterface::class);
    $feature1->shouldReceive('getName')->andReturn('feature-1');
    $feature1->shouldReceive('getPriority')->andReturn(10);
    $feature1->shouldReceive('shouldGenerate')->with(['test' => true])->andReturn(true);
    $feature1->shouldReceive('getDirectories')->with(['test' => true])->andReturn(['src', 'tests']);

    $feature2 = Mockery::mock(PluginFeatureInterface::class);
    $feature2->shouldReceive('getName')->andReturn('feature-2');
    $feature2->shouldReceive('getPriority')->andReturn(20);
    $feature2->shouldReceive('shouldGenerate')->with(['test' => true])->andReturn(true);
    $feature2->shouldReceive('getDirectories')->with(['test' => true])->andReturn(['config', 'tests']);

    $this->factory->registerMany([$feature1, $feature2]);

    $directories = $this->factory->getDirectories(['test' => true]);

    expect($directories)->toContain('src')
        ->and($directories)->toContain('tests')
        ->and($directories)->toContain('config')
        ->and($directories)->toHaveCount(3); // 'tests' should be unique
});

test('skips features that should not be generated', function () {
    $feature1 = Mockery::mock(PluginFeatureInterface::class);
    $feature1->shouldReceive('getName')->andReturn('feature-1');
    $feature1->shouldReceive('getPriority')->andReturn(10);
    $feature1->shouldReceive('shouldGenerate')->with(['enabled' => false])->andReturn(false);

    $feature2 = Mockery::mock(PluginFeatureInterface::class);
    $feature2->shouldReceive('getName')->andReturn('feature-2');
    $feature2->shouldReceive('getPriority')->andReturn(20);
    $feature2->shouldReceive('shouldGenerate')->with(['enabled' => false])->andReturn(true);
    $feature2->shouldReceive('getDirectories')->with(['enabled' => false])->andReturn(['config']);

    $this->factory->registerMany([$feature1, $feature2]);

    $directories = $this->factory->getDirectories(['enabled' => false]);

    expect($directories)->toHaveCount(1)
        ->and($directories)->toContain('config');
});

test('can generate all features', function () {
    $feature1 = Mockery::mock(PluginFeatureInterface::class);
    $feature1->shouldReceive('getName')->andReturn('feature-1');
    $feature1->shouldReceive('getPriority')->andReturn(10);
    $feature1->shouldReceive('shouldGenerate')->with(['test' => true])->andReturn(true);
    $feature1->shouldReceive('generate')->once()->with(['test' => true]);

    $feature2 = Mockery::mock(PluginFeatureInterface::class);
    $feature2->shouldReceive('getName')->andReturn('feature-2');
    $feature2->shouldReceive('getPriority')->andReturn(20);
    $feature2->shouldReceive('shouldGenerate')->with(['test' => true])->andReturn(false);

    $this->factory->registerMany([$feature1, $feature2]);

    $this->factory->generateAll(['test' => true]);

    // Expectations are verified by Mockery
});

test('can generate specific feature by name', function () {
    $feature = Mockery::mock(PluginFeatureInterface::class);
    $feature->shouldReceive('getName')->andReturn('test-feature');
    $feature->shouldReceive('shouldGenerate')->with(['config' => 'value'])->andReturn(true);
    $feature->shouldReceive('generate')->once()->with(['config' => 'value']);

    $this->factory->register($feature);

    $this->factory->generate('test-feature', ['config' => 'value']);
});

test('throws exception when generating non-existent feature', function () {
    $this->factory->generate('non-existent', []);
})->throws(InvalidArgumentException::class, "Feature 'non-existent' not registered");

test('does not generate feature when shouldGenerate returns false', function () {
    $feature = Mockery::mock(PluginFeatureInterface::class);
    $feature->shouldReceive('getName')->andReturn('test-feature');
    $feature->shouldReceive('shouldGenerate')->with(['enabled' => false])->andReturn(false);
    $feature->shouldReceive('generate')->never();

    $this->factory->register($feature);

    $this->factory->generate('test-feature', ['enabled' => false]);
});

afterEach(function () {
    Mockery::close();
});
</file>

<file path="tests/Unit/StubProcessorTest.php">
<?php

use Illuminate\Filesystem\Filesystem;
use Laravilt\Plugins\Services\Generation\StubProcessor;

beforeEach(function () {
    $this->files = Mockery::mock(Filesystem::class);
    $this->processor = new StubProcessor($this->files);
});

afterEach(function () {
    Mockery::close();
});

test('can process stub with replacements', function () {
    $stubContent = 'Hello {{ name }}, your email is {{ email }}';

    $this->files->shouldReceive('exists')
        ->once()
        ->with(Mockery::pattern('/Stubs\/test\.stub$/'))
        ->andReturn(true);

    $this->files->shouldReceive('get')
        ->once()
        ->andReturn($stubContent);

    $result = $this->processor->process('test', [
        'name' => 'John',
        'email' => 'john@example.com',
    ]);

    expect($result)->toBe('Hello John, your email is john@example.com');
});

test('throws exception when stub file not found', function () {
    $this->files->shouldReceive('exists')
        ->once()
        ->andReturn(false);

    $this->processor->process('nonexistent', []);
})->throws(RuntimeException::class, 'Stub file not found');

test('can generate file from stub', function () {
    $stubContent = 'class {{ class }} {}';
    $expectedContent = 'class TestClass {}';

    $this->files->shouldReceive('exists')
        ->once()
        ->andReturn(true);

    $this->files->shouldReceive('get')
        ->once()
        ->andReturn($stubContent);

    $this->files->shouldReceive('ensureDirectoryExists')
        ->once()
        ->with('/path/to');

    $this->files->shouldReceive('put')
        ->once()
        ->with('/path/to/TestClass.php', $expectedContent);

    $this->processor->generateFile('/path/to/TestClass.php', 'test', [
        'class' => 'TestClass',
    ]);
});

test('handles multiple replacements in single stub', function () {
    $stubContent = '{{ namespace }}\\{{ class }} extends {{ parent }}';

    $this->files->shouldReceive('exists')->andReturn(true);
    $this->files->shouldReceive('get')->andReturn($stubContent);

    $result = $this->processor->process('test', [
        'namespace' => 'App\\Models',
        'class' => 'User',
        'parent' => 'Model',
    ]);

    expect($result)->toBe('App\\Models\\User extends Model');
});

test('handles stub with no replacements', function () {
    $stubContent = 'No placeholders here';

    $this->files->shouldReceive('exists')->andReturn(true);
    $this->files->shouldReceive('get')->andReturn($stubContent);

    $result = $this->processor->process('test', []);

    expect($result)->toBe('No placeholders here');
});
</file>

<file path="tests/Pest.php">
<?php

use Laravilt\Plugins\Tests\TestCase;

uses(TestCase::class)->in('Feature', 'Unit');
</file>

<file path="CHANGELOG.md">
# Changelog

All notable changes to `Laravilt Plugins` will be documented in this file.

## 1.0.0 - TBD

### Added
- Initial release
- Plugin generator command (`laravilt:plugin`)
- Plugin manager and discovery system
- FilamentPHP compatibility
- Professional package structure generation
- GitHub Actions workflows
- Testing configuration (PHPUnit, Pest, PHPStan, Pint)
- Laravel Prompts integration
- i18n support (English + Arabic)
- Sample components and widgets generation
- Asset build configuration (Vite, Vue, Tailwind)
- Documentation structure
- Laravel Workbench setup

### Features
- Auto-discovery of plugins from installed packages
- Plugin registration and lifecycle management
- Configurable plugin system
- Professional naming conventions
- Complete testing infrastructure
- Code quality tools integration
</file>

<file path="CODE_OF_CONDUCT.md">
# Code of Conduct

## Our Pledge

We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.

## Our Standards

Examples of behavior that contributes to a positive environment for our community include:

- Being respectful of differing opinions, viewpoints, and experiences
- Giving and gracefully accepting constructive feedback
- Accepting responsibility and apologizing to those affected by our mistakes
- Focusing on what is best not just for us as individuals, but for the overall community
- Showing empathy towards other community members

Examples of unacceptable behavior include:

- The use of sexualized language or imagery, and sexual attention or advances of any kind
- Trolling, insulting or derogatory comments, and personal or political attacks
- Public or private harassment
- Publishing others' private information without their explicit permission
- Other conduct which could reasonably be considered inappropriate in a professional setting

## Enforcement Responsibilities

Community leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful.

## Scope

This Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces.

## Enforcement

Instances of abusive, harassing, or otherwise unacceptable behavior may be reported to the community leaders responsible for enforcement at conduct@laravilt.com.

All complaints will be reviewed and investigated promptly and fairly.

All community leaders are obligated to respect the privacy and security of the reporter of any incident.

## Attribution

This Code of Conduct is adapted from the [Contributor Covenant][homepage], version 2.1, available at [https://www.contributor-covenant.org/version/2/1/code_of_conduct.html][v2.1].

[homepage]: https://www.contributor-covenant.org
[v2.1]: https://www.contributor-covenant.org/version/2/1/code_of_conduct.html
</file>

<file path="LICENSE.md">
# The MIT License (MIT)

Copyright (c) Laravilt <hello@laravilt.com>

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
</file>

<file path="phpunit.xml">
<?xml version="1.0" encoding="UTF-8"?>
<phpunit xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:noNamespaceSchemaLocation="vendor/phpunit/phpunit/phpunit.xsd"
         bootstrap="vendor/autoload.php"
         colors="true"
>
    <testsuites>
        <testsuite name="Laravilt Plugins Test Suite">
            <directory suffix="Test.php">./tests</directory>
        </testsuite>
    </testsuites>
    <coverage>
        <include>
            <directory suffix=".php">./src</directory>
        </include>
    </coverage>
</phpunit>
</file>

<file path="pint.json">
{
    "preset": "laravel",
    "rules": {
        "simplified_null_return": true,
        "braces": false,
        "new_with_braces": {
            "anonymous_class": false,
            "named_class": false
        }
    }
}
</file>

<file path="SECURITY.md">
# Security Policy

## Reporting a Vulnerability

If you discover a security vulnerability within Laravilt Plugins, please send an email to security@laravilt.com.

All security vulnerabilities will be promptly addressed.

Please do not publicly disclose the issue until it has been addressed by the team.

## Supported Versions

We release patches for security vulnerabilities for the following versions:

| Version | Supported          |
| ------- | ------------------ |
| 1.x     | :white_check_mark: |

## Security Update Process

1. The security team will acknowledge receipt of your vulnerability report within 48 hours
2. The team will investigate and confirm the issue
3. A fix will be developed and tested
4. A security release will be published
5. The vulnerability will be publicly disclosed after users have had time to update
</file>

<file path="testbench.yaml">
providers:
  - Laravilt\Plugins\PluginsServiceProvider

workbench:
  start: '/'
  install: true
  welcome: false
</file>

<file path=".github/workflows/dependabot-auto-merge.yml">
name: Dependabot Auto-Merge

on: [push, pull_request]

permissions:
  pull-requests: write
  contents: write

jobs:
  dependabot:
    runs-on: ubuntu-latest
    if: ${{ github.actor == 'dependabot[bot]' }}
    steps:
      - name: Dependabot metadata
        id: metadata
        uses: dependabot/fetch-metadata@v2
        with:
          github-token: "${{ secrets.GITHUB_TOKEN }}"

      - name: Auto-merge Dependabot PRs for semver-minor updates
        if: ${{steps.metadata.outputs.update-type == 'version-update:semver-minor'}}
        run: gh pr merge --auto --merge "$PR_URL"
        env:
          PR_URL: ${{github.event.pull_request.html_url}}
          GITHUB_TOKEN: ${{secrets.GITHUB_TOKEN}}

      - name: Auto-merge Dependabot PRs for semver-patch updates
        if: ${{steps.metadata.outputs.update-type == 'version-update:semver-patch'}}
        run: gh pr merge --auto --merge "$PR_URL"
        env:
          PR_URL: ${{github.event.pull_request.html_url}}
          GITHUB_TOKEN: ${{secrets.GITHUB_TOKEN}}
</file>

<file path="docs/index.md">
# Laravilt Plugins Documentation

Complete plugin system with generator, management, and FilamentPHP v4 compatibility for Laravilt.ipsum

## Table of Contents

1. [Getting Started](getting-started.md)
2. [Architecture](architecture.md)
3. [Plugin Generation](plugin-generation.md)
4. [Component Generators](component-generators.md)
5. [Factory Pattern](factory-pattern.md)
6. [Features System](features-system.md)
7. [MCP Server Integration](mcp-server.md)
8. [API Reference](api-reference.md)

## Overview

Laravilt Plugins is a comprehensive plugin management system that provides:

- **Plugin Generator**: Create complete Laravel packages with service providers, configuration, and FilamentPHP integration
- **Component Generators**: Generate migrations, models, controllers, commands, and more within plugins
- **Factory Pattern Architecture**: Extensible feature system for plugin generation
- **MCP Server**: AI agent integration for plugin management
- **GitHub Integration**: Automated workflows, issue templates, and sponsorship
- **Professional Assets**: Cover images, documentation, and coding standards

## Quick Start

```bash
# Generate a new plugin
php artisan laravilt:plugin BlogExtensions

# Generate components within a plugin
php artisan laravilt:make blog-extensions model Post
php artisan laravilt:make blog-extensions controller PostController
php artisan laravilt:make blog-extensions migration CreatePostsTable

# Install MCP server for AI agents
php artisan laravilt:install-mcp
```

## Key Features

### 🎨 Plugin Generator
- Complete package structure
- Service provider with auto-discovery
- Configuration files
- Optional migrations, views, routes, assets

### 🧩 Component Generators
13 component types:
- Migration, Model, Controller, Command
- Job, Event, Listener, Notification
- Seeder, Factory, Test
- Language, Route

### 🏭 Factory Pattern
- Extensible architecture
- Priority-based execution
- Feature registration system
- Stub-based generation

### 🤖 MCP Server
- AI agent integration
- Plugin management tools
- Component generation
- Structure inspection

### 🎨 Professional Assets
- Cover images (1200x630px)
- Dark theme with branding
- README integration
- Social media ready

### ⚙️ GitHub Integration
- Automated workflows
- Issue templates
- Dependabot configuration
- FUNDING.yml support

## System Requirements

- PHP 8.3+
- Laravel 12+
- FilamentPHP v4 (for plugin features)
- Composer 2+

## Installation

```bash
composer require laravilt/plugins
```

The service provider is auto-discovered and will register automatically.

## Configuration

Publish the configuration:

```bash
php artisan vendor:publish --tag=laravilt-plugins-config
```

## Next Steps

- [Getting Started Guide](getting-started.md) - First steps with plugin generation
- [Architecture Overview](architecture.md) - Understanding the system design
- [Component Generators](component-generators.md) - Detailed component generation guide
- [MCP Server](mcp-server.md) - AI agent integration

## Support

- GitHub Issues: github.com/laravilt/plugins
- Documentation: docs.laravilt.com
- Discord: discord.laravilt.com
</file>

<file path="docs/mcp-server.md">
# MCP Server Integration

The Laravilt Plugins package includes a built-in MCP (Model Context Protocol) server that allows AI agents to interact with the plugin system.

## Installation

Install the MCP server configuration:

```bash
php artisan laravilt:install-mcp
```

This command will:

1. **Publish `routes/ai.php`** (if it doesn't exist) - Laravel MCP routes file
2. **Register the server** in `routes/ai.php`:
   ```php
   use Laravel\Mcp\Facades\Mcp;
   use Laravilt\Plugins\Mcp\LaraviltPluginsServer;

   Mcp::local('laravilt-plugins', LaraviltPluginsServer::class);
   ```
3. **Update `.mcp.json`** for AI clients:
   ```json
   {
     "mcpServers": {
       "laravilt-plugins": {
         "command": "php",
         "args": [
           "artisan",
           "mcp:start",
           "laravilt-plugins"
         ]
       }
     }
   }
   ```

After installation, restart your AI agent application (Claude Desktop, etc.) to load the new MCP server.

## Available Tools

### list-plugins
List all installed Laravilt plugins in the packages directory.

**Usage:**
```
list-plugins
```

**Output:**
```
Found 3 plugin(s):

📦 actions
   Package: laravilt/actions
   Version: 1.0.0
   Description: Actions plugin for Laravilt
   Path: /path/to/packages/laravilt/actions
...
```

### plugin-info
Get detailed information about a specific plugin including structure, features, and configuration.

**Arguments:**
- `plugin` (string): The plugin name in kebab-case

**Usage:**
```
plugin-info(plugin="blog-extensions")
```

**Output:**
- Package information (name, description, version)
- Directory structure
- Available features (migrations, models, views, etc.)

### generate-plugin
Generate a new Laravilt plugin with specified features.

**Arguments:**
- `name` (string, required): Plugin name in StudlyCase
- `description` (string, optional): Plugin description
- `migrations` (bool, default: false): Include database migrations
- `views` (bool, default: false): Include Blade views
- `webRoutes` (bool, default: false): Include web routes
- `apiRoutes` (bool, default: false): Include API routes
- `css` (bool, default: false): Include CSS assets
- `js` (bool, default: false): Include JavaScript assets
- `arts` (bool, default: true): Include arts folder with cover photo
- `github` (bool, default: true): Include GitHub workflows
- `phpstan` (bool, default: true): Include PHPStan configuration

**Usage:**
```
generate-plugin(
  name="BlogExtensions",
  description="Blog extensions for Laravilt",
  migrations=true,
  views=true,
  css=true
)
```

### generate-component
Generate a Laravel component within a plugin.

**Arguments:**
- `plugin` (string, required): Plugin name in kebab-case
- `type` (string, required): Component type
- `name` (string, required): Component name

**Component Types:**
- `migration` - Database migration
- `model` - Eloquent model
- `controller` - HTTP controller
- `command` - Artisan command
- `job` - Queueable job
- `event` - Event class
- `listener` - Event listener
- `notification` - Notification
- `seeder` - Database seeder
- `factory` - Model factory
- `test` - Feature test
- `lang` - Language file
- `route` - Route file

**Usage:**
```
generate-component(
  plugin="blog-extensions",
  type="model",
  name="Post"
)
```

### list-component-types
List all available component types that can be generated.

**Usage:**
```
list-component-types
```

### plugin-structure
Get the complete directory structure of a plugin.

**Arguments:**
- `plugin` (string): Plugin name in kebab-case

**Usage:**
```
plugin-structure(plugin="blog-extensions")
```

## AI Agent Examples

### Claude Desktop / Claude Code

```
You: "List all installed plugins"
Claude: [calls list-plugins tool]

You: "Create a new plugin called BlogExtensions with migrations and views"
Claude: [calls generate-plugin with appropriate parameters]

You: "Generate a Post model in the blog-extensions plugin"
Claude: [calls generate-component with plugin="blog-extensions", type="model", name="Post"]
```

### Use Cases

1. **Plugin Discovery**: AI agents can explore installed plugins
2. **Automated Generation**: Create plugins and components through natural language
3. **Structure Analysis**: Inspect plugin architecture and features
4. **Development Assistance**: Quick component generation during development

## Security

The MCP server runs with the same permissions as your Laravel application. Ensure:
- Proper file permissions on the packages directory
- Secure configuration of the MCP server
- Limited access to the MCP configuration file

## Troubleshooting

### Server Not Found

If the AI agent can't find the server:
1. Check `.mcp/config.json` exists
2. Verify the artisan path is correct
3. Restart the AI agent application

### Permission Errors

Ensure the packages directory is writable:
```bash
chmod -R 775 packages/laravilt
```

### Tool Execution Failures

Check Laravel logs for detailed error messages:
```bash
tail -f storage/logs/laravel.log
```
</file>

<file path="src/Commands/InstallMcpServerCommand.php">
<?php

namespace Laravilt\Plugins\Commands;

use Illuminate\Console\Command;
use Illuminate\Support\Facades\File;

class InstallMcpServerCommand extends Command
{
    protected $signature = 'laravilt:install-mcp';

    protected $description = 'Install the Laravilt Plugins MCP server configuration';

    public function handle(): int
    {
        $this->info('Installing Laravilt Plugins MCP server...');
        $this->newLine();

        // Step 1: Publish routes/ai.php if it doesn't exist
        $this->publishAiRoutes();

        // Step 2: Register MCP server in routes/ai.php
        $this->registerMcpServer();

        // Step 3: Create .mcp/config.json for MCP clients
        $this->createMcpConfig();

        $this->newLine();
        $this->components->info('✅ Laravilt Plugins MCP server installed successfully!');
        $this->newLine();

        $this->components->bulletList([
            'Server name: laravilt-plugins',
            'Server type: Local (Artisan command)',
            'Tools available: list-plugins, plugin-info, generate-plugin, generate-component, list-component-types, plugin-structure',
        ]);

        $this->newLine();
        $this->components->info('AI agents can now access plugin management features through the MCP server!');
        $this->newLine();

        $this->components->warn('Next steps:');
        $this->components->bulletList([
            'Restart your AI agent application (Claude Desktop, etc.)',
            'The laravilt-plugins server should now be available',
        ]);

        return self::SUCCESS;
    }

    protected function publishAiRoutes(): void
    {
        $aiRoutesPath = base_path('routes/ai.php');

        if (! File::exists($aiRoutesPath)) {
            $this->info('Publishing routes/ai.php...');
            $this->call('vendor:publish', ['--tag' => 'ai-routes']);
            $this->info('✓ Published routes/ai.php');
        } else {
            $this->info('✓ routes/ai.php already exists');
        }
    }

    protected function registerMcpServer(): void
    {
        $aiRoutesPath = base_path('routes/ai.php');

        if (! File::exists($aiRoutesPath)) {
            $this->error('✗ routes/ai.php not found. Cannot register MCP server.');

            return;
        }

        $content = File::get($aiRoutesPath);

        // Check if already registered
        if (str_contains($content, 'laravilt-plugins') || str_contains($content, 'LaraviltPluginsServer')) {
            $this->info('✓ MCP server already registered in routes/ai.php');

            return;
        }

        // Add the necessary use statements
        $useStatements = "use Laravilt\Plugins\Mcp\LaraviltPluginsServer;\n";

        // Check if Laravel\Mcp\Facades\Mcp is already imported
        if (! str_contains($content, 'use Laravel\Mcp\Facades\Mcp;')) {
            $useStatements = "use Laravel\Mcp\Facades\Mcp;\n".$useStatements;
        }

        // Find the position to insert use statements (after <?php and namespace if present)
        $lines = explode("\n", $content);
        $insertPosition = 0;

        foreach ($lines as $index => $line) {
            if (str_starts_with(trim($line), 'use ')) {
                $insertPosition = $index;
                break;
            }
            if (str_starts_with(trim($line), '<?php')) {
                $insertPosition = $index + 1;
            }
        }

        // Insert use statements
        if ($insertPosition > 0) {
            array_splice($lines, $insertPosition, 0, rtrim($useStatements));
            $content = implode("\n", $lines);
        } else {
            // If no use statements found, add after <?php
            $content = str_replace("<?php\n", "<?php\n\n".$useStatements, $content);
        }

        // Add the MCP server registration at the end of the file
        $serverRegistration = "\n// Laravilt Plugins MCP Server\nMcp::local('laravilt-plugins', LaraviltPluginsServer::class);\n";

        $content = rtrim($content).$serverRegistration;

        File::put($aiRoutesPath, $content);

        $this->info('✓ Registered MCP server in routes/ai.php');
    }

    protected function createMcpConfig(): void
    {
        $mcpConfigPath = base_path('.mcp.json');

        // Read existing config or create new one
        $config = [];
        if (File::exists($mcpConfigPath)) {
            $config = json_decode(File::get($mcpConfigPath), true) ?? [];
        }

        // Add laravilt-plugins server
        if (! isset($config['mcpServers'])) {
            $config['mcpServers'] = [];
        }

        $config['mcpServers']['laravilt-plugins'] = [
            'command' => 'php',
            'args' => [
                'artisan',
                'mcp:start',
                'laravilt-plugins',
            ],
            'cwd' => base_path(),
        ];

        // Write config
        File::put(
            $mcpConfigPath,
            json_encode($config, JSON_PRETTY_PRINT | JSON_UNESCAPED_SLASHES)
        );

        $this->info('✓ Updated .mcp.json');
    }
}
</file>

<file path="src/Mcp/Tools/PluginStructureTool.php">
<?php

namespace Laravilt\Plugins\Mcp\Tools;

use Illuminate\JsonSchema\JsonSchema;
use Illuminate\Support\Facades\File;
use Laravel\Mcp\Request;
use Laravel\Mcp\Response;
use Laravel\Mcp\Server\Tool;

class PluginStructureTool extends Tool
{
    /**
     * The tool's description.
     */
    protected string $description = 'Get the complete directory structure of a plugin';

    /**
     * Handle the tool request.
     */
    public function handle(Request $request): Response
    {
        $plugin = $request->string('plugin');
        $pluginPath = base_path("packages/laravilt/{$plugin}");

        if (! File::isDirectory($pluginPath)) {
            return Response::text("Plugin '{$plugin}' not found at {$pluginPath}");
        }

        $structure = $this->getDirectoryTree($pluginPath);

        $output = "Plugin Structure: {$plugin}\n\n";
        $output .= $structure;

        return Response::text($output);
    }

    /**
     * Get the tool's input schema.
     *
     * @return array<string, \Illuminate\JsonSchema\JsonSchema>
     */
    public function schema(JsonSchema $schema): array
    {
        return [
            'plugin' => $schema->string()
                ->description('Plugin name (kebab-case)')
                ->required(),
        ];
    }

    protected function getDirectoryTree(string $path, string $prefix = ''): string
    {
        $tree = '';
        $ignoredPatterns = $this->getIgnoredPatterns($path);

        // Create a custom recursive directory iterator that skips ignored paths
        $directory = new \RecursiveDirectoryIterator($path, \RecursiveDirectoryIterator::SKIP_DOTS);
        $filter = new class($directory, $ignoredPatterns, $path) extends \RecursiveFilterIterator
        {
            private array $ignoredPatterns;

            private string $basePath;

            public function __construct(\RecursiveDirectoryIterator $iterator, array $ignoredPatterns, string $basePath)
            {
                parent::__construct($iterator);
                $this->ignoredPatterns = $ignoredPatterns;
                $this->basePath = rtrim($basePath, '/');
            }

            public function accept(): bool
            {
                $item = $this->current();
                $relativePath = str_replace($this->basePath.'/', '', $item->getPathname());

                // If this is a directory and it matches an ignore pattern, skip it entirely
                if ($item->isDir() && $this->shouldIgnore($relativePath)) {
                    return false;
                }

                // For files, check if their path matches an ignore pattern
                return ! $this->shouldIgnore($relativePath);
            }

            public function getChildren(): ?\RecursiveFilterIterator
            {
                return new self($this->getInnerIterator()->getChildren(), $this->ignoredPatterns, $this->basePath);
            }

            private function shouldIgnore(string $path): bool
            {
                foreach ($this->ignoredPatterns as $pattern) {
                    // Remove leading slash for comparison
                    $pattern = ltrim($pattern, '/');

                    // Handle directory patterns (ending with /)
                    if (str_ends_with($pattern, '/')) {
                        $pattern = rtrim($pattern, '/');
                        if (str_starts_with($path, $pattern.'/') || $path === $pattern) {
                            return true;
                        }
                    }
                    // Handle wildcard patterns
                    elseif (str_contains($pattern, '*')) {
                        // Convert glob pattern to regex
                        $regex = '/^'.str_replace(['\*'], ['.*'], preg_quote($pattern, '/')).'$/';
                        if (preg_match($regex, $path)) {
                            return true;
                        }
                    }
                    // Handle exact match or prefix match
                    else {
                        if ($path === $pattern || str_starts_with($path, $pattern.'/')) {
                            return true;
                        }
                    }
                }

                return false;
            }
        };

        $iterator = new \RecursiveIteratorIterator($filter, \RecursiveIteratorIterator::SELF_FIRST);

        foreach ($iterator as $item) {
            // Only include files, not directories
            if ($item->isFile()) {
                $relativePath = str_replace($path.'/', '', $item->getPathname());
                $tree .= $prefix.$relativePath."\n";
            }
        }

        return $tree;
    }

    /**
     * Get ignored patterns from .gitignore file.
     */
    protected function getIgnoredPatterns(string $path): array
    {
        $patterns = [
            'vendor/',
            'node_modules/',
        ];

        $gitignorePath = $path.'/.gitignore';
        if (File::exists($gitignorePath)) {
            $gitignoreContent = File::get($gitignorePath);
            $lines = explode("\n", $gitignoreContent);

            foreach ($lines as $line) {
                $line = trim($line);
                // Skip empty lines and comments
                if (empty($line) || str_starts_with($line, '#')) {
                    continue;
                }
                $patterns[] = $line;
            }
        }

        return $patterns;
    }
}
</file>

<file path="src/Mcp/LaraviltPluginsServer.php">
<?php

namespace Laravilt\Plugins\Mcp;

use Laravel\Mcp\Server;
use Laravilt\Plugins\Mcp\Tools\GenerateComponentTool;
use Laravilt\Plugins\Mcp\Tools\GeneratePluginTool;
use Laravilt\Plugins\Mcp\Tools\ListComponentTypesTool;
use Laravilt\Plugins\Mcp\Tools\ListPluginsTool;
use Laravilt\Plugins\Mcp\Tools\PluginInfoTool;
use Laravilt\Plugins\Mcp\Tools\PluginStructureTool;
use Laravilt\Plugins\Mcp\Tools\SearchDocsTool;

class LaraviltPluginsServer extends Server
{
    /**
     * The MCP server's name.
     */
    protected string $name = 'Laravilt Plugins';

    /**
     * The MCP server's version.
     */
    protected string $version = '1.0.0';

    /**
     * The MCP server's instructions for the LLM.
     */
    protected string $instructions = <<<'MARKDOWN'
        This server provides plugin management capabilities for Laravilt projects.

        You can:
        - List all installed plugins
        - Get detailed information about specific plugins
        - Generate new plugins with various features
        - Generate components within plugins (models, controllers, migrations, etc.)
        - View plugin directory structures (excluding vendor/node_modules)
        - List available component types
        - Search plugin documentation to understand features and architecture

        All plugins are located in the packages/laravilt directory.
    MARKDOWN;

    /**
     * The tools registered with this MCP server.
     *
     * @var array<int, class-string<\Laravel\Mcp\Server\Tool>>
     */
    protected array $tools = [
        ListPluginsTool::class,
        PluginInfoTool::class,
        GeneratePluginTool::class,
        GenerateComponentTool::class,
        ListComponentTypesTool::class,
        PluginStructureTool::class,
        SearchDocsTool::class,
    ];
}
</file>

<file path="src/Services/PluginGenerator.php">
<?php

namespace Laravilt\Plugins\Services;

use Illuminate\Filesystem\Filesystem;
use Illuminate\Support\Str;

/**
 * Orchestrates plugin generation using the Factory Pattern.
 *
 * This service uses the PluginFeatureFactory to manage all plugin features.
 * Features are executed in priority order with proper dependency management.
 */
class PluginGenerator
{
    public function __construct(
        protected Filesystem $files,
        protected PluginFeatureFactory $featureFactory
    ) {}

    /**
     * Create the plugin directory structure based on configuration.
     *
     * Uses the PluginFeatureFactory to collect directories from all features.
     */
    public function createDirectoryStructure(string $basePath, array $config): void
    {
        $directories = $this->featureFactory->getDirectories($config);

        foreach ($directories as $dir) {
            $this->files->makeDirectory("{$basePath}/{$dir}", 0755, true, true);
        }
    }

    /**
     * Generate all plugin files using the Factory Pattern.
     *
     * Delegates to PluginFeatureFactory which executes features in priority order.
     */
    public function generateAllFiles(array $config): void
    {
        $this->featureFactory->generateAll($config);
    }

    /**
     * Prepare configuration array for generators.
     */
    public function prepareConfig(string $name, string $vendor, string $basePath, bool $generatePlugin = true, array $options = []): array
    {
        $studlyName = Str::studly($name);
        $kebabName = Str::kebab($name);
        $snakeName = Str::snake($name);
        $vendorLower = Str::lower($vendor);
        $namespace = Str::studly($vendorLower).'\\'.$studlyName;

        return array_merge([
            'name' => $name,
            'studly_name' => $studlyName,
            'kebab_name' => $kebabName,
            'snake_name' => $snakeName,
            'vendor' => $vendor,
            'vendor_lower' => $vendorLower,
            'namespace' => $namespace,
            'base_path' => $basePath,
            'config_name' => 'laravilt-'.$kebabName,
            'env_prefix' => 'LARAVILT_'.strtoupper($snakeName),
            'assets_tag' => 'laravilt-'.$kebabName.'-assets',
            'service_provider' => $studlyName.'ServiceProvider',
            'generate_plugin' => $generatePlugin,
            'author' => config('laravilt-plugins.defaults.author', 'Fady Mondy'),
            'email' => config('laravilt-plugins.defaults.email', 'info@3x1.io'),
            'license' => config('laravilt-plugins.defaults.license', 'MIT'),
        ], $options);
    }
}
</file>

<file path="src/Stubs/package.json.stub">
{
    "name": "{{ package }}",
    "version": "1.0.0",
    "private": true,
    "type": "module",
    "scripts": {
        "dev": "vite",
        "build": "vite build",
        "format": "prettier --write resources/",
        "format:check": "prettier --check resources/",
        "lint": "eslint . --fix"
    },
    "devDependencies": {
        "@eslint/js": "^9.19.0",
        "@tailwindcss/vite": "^4.1.11",
        "@types/node": "^22.13.5",
        "@vitejs/plugin-vue": "^6.0.0",
        "@vue/eslint-config-typescript": "^14.3.0",
        "eslint": "^9.17.0",
        "eslint-config-prettier": "^10.0.1",
        "eslint-plugin-vue": "^9.32.0",
        "prettier": "^3.4.2",
        "prettier-plugin-organize-imports": "^4.1.0",
        "prettier-plugin-tailwindcss": "^0.6.11",
        "typescript": "^5.2.2",
        "typescript-eslint": "^8.23.0",
        "vite": "^7.0.4",
        "vue-tsc": "^2.2.4"
    },
    "dependencies": {
        "laravel-vite-plugin": "^2.0.0",
        "tailwindcss": "^4.1.1",
        "vue": "^3.5.13"
    },
    "optionalDependencies": {
        "@rollup/rollup-linux-x64-gnu": "4.9.5",
        "@rollup/rollup-win32-x64-msvc": "4.9.5",
        "@tailwindcss/oxide-linux-x64-gnu": "^4.0.1",
        "@tailwindcss/oxide-win32-x64-msvc": "^4.0.1",
        "lightningcss-linux-x64-gnu": "^1.29.1",
        "lightningcss-win32-x64-msvc": "^1.29.1"
    }
}
</file>

<file path="src/Stubs/plugin.stub">
<?php

namespace {{ namespace }};

use Filament\Contracts\Plugin;
use Filament\Panel;
use Laravilt\Plugins\PluginProvider;

class {{ class }} extends PluginProvider implements Plugin
{
    /**
     * The plugin ID (must be unique).
     */
    protected static string $id = '{{ id }}';

    /**
     * The plugin name.
     */
    protected static string $name = '{{ name }}';

    /**
     * The plugin version.
     */
    protected static string $version = '1.0.0';

    /**
     * The plugin description.
     */
    protected static string $description = '{{ description }}';

    /**
     * The plugin author.
     */
    protected static string $author = '{{ author }}';

    /**
     * Register the plugin with a Filament panel.
     *
     * This is where you register resources, pages, widgets, and other
     * Filament-specific components that should be available in the panel.
     */
    public function register(Panel $panel): void
    {
        // Register resources
        // $panel->resources([
        //     Resources\YourResource::class,
        // ]);

        // Register pages
        // $panel->pages([
        //     Pages\YourPage::class,
        // ]);

        // Register widgets
        // $panel->widgets([
        //     Widgets\StatsWidget::class,
        // ]);

        // Register render hooks
        // $panel->renderHook(
        //     'panels::body.end',
        //     fn () => view('{{ id }}::scripts')
        // );
    }

    /**
     * Boot the plugin for a panel.
     *
     * This method is called after the plugin is registered.
     * Use it for panel-specific initialization logic.
     */
    public function boot(Panel $panel): void
    {
        // Add panel-specific boot logic if needed
        // For example, register navigation items, custom themes, etc.
    }

    /**
     * Get the plugin ID.
     */
    public function getId(): string
    {
        return static::$id;
    }
}
</file>

<file path="src/Stubs/README.md.stub">
![{{ plugin_name }}](./arts/screenshot.jpg)

# {{ plugin_name }} Plugin for Laravilt

{{ badges }}

{{ description }}

## Installation

You can install the plugin via composer:

```bash
composer require {{ vendor }}/{{ package }}
```

The package will automatically register its service provider which handles all Laravel-specific functionality (views, migrations, config, etc.).
{{ laravilt_usage }}
## Configuration

Publish the config file:

```bash
php artisan vendor:publish --tag="{{ config }}-config"
```

## Assets

Publish the plugin assets:

```bash
php artisan vendor:publish --tag="{{ assets_tag }}"
```

## Testing

```bash
composer test
```

## Code Style

```bash
composer format
```

## Static Analysis

```bash
composer analyse
```

## License

The MIT License (MIT). Please see [License File](LICENSE.md) for more information.
</file>

<file path="src/Support/PluginDiscovery.php">
<?php

namespace Laravilt\Plugins\Support;

use Illuminate\Contracts\Foundation\Application;
use Illuminate\Support\Collection;
use Laravilt\Plugins\Contracts\Plugin;

class PluginDiscovery
{
    protected Application $app;

    public function __construct(Application $app)
    {
        $this->app = $app;
    }

    /**
     * Discover all plugins.
     *
     * @return Collection<Plugin>
     */
    public function discover(): Collection
    {
        $plugins = collect();

        // Check installed packages for Laravilt plugins
        $installedPackages = $this->getInstalledPackages();

        foreach ($installedPackages as $package) {
            if ($this->isLaraviltPlugin($package)) {
                $plugin = $this->loadPlugin($package);

                if ($plugin) {
                    $plugins->push($plugin);
                }
            }
        }

        return $plugins;
    }

    /**
     * Get installed packages from composer.lock.
     */
    protected function getInstalledPackages(): Collection
    {
        $composerLockPath = base_path('composer.lock');

        if (! file_exists($composerLockPath)) {
            return collect();
        }

        $composerLock = json_decode(file_get_contents($composerLockPath), true);

        return collect($composerLock['packages'] ?? []);
    }

    /**
     * Check if a package is a Laravilt plugin.
     */
    protected function isLaraviltPlugin(array $package): bool
    {
        $extra = $package['extra'] ?? [];
        $laravel = $extra['laravel'] ?? [];

        if (isset($laravel['providers'])) {
            foreach ($laravel['providers'] as $provider) {
                if ($this->isPluginProvider($provider)) {
                    return true;
                }
            }
        }

        return false;
    }

    /**
     * Check if a provider is a plugin provider.
     */
    protected function isPluginProvider(string $provider): bool
    {
        if (! class_exists($provider)) {
            return false;
        }

        $interfaces = class_implements($provider);

        return is_array($interfaces) && in_array(Plugin::class, $interfaces);
    }

    /**
     * Load a plugin from a package.
     */
    protected function loadPlugin(array $package): ?Plugin
    {
        $extra = $package['extra'] ?? [];
        $laravel = $extra['laravel'] ?? [];
        $providers = $laravel['providers'] ?? [];

        foreach ($providers as $provider) {
            if ($this->isPluginProvider($provider)) {
                return $this->app->make($provider);
            }
        }

        return null;
    }
}
</file>

<file path="src/Support/PluginManifest.php">
<?php

namespace Laravilt\Plugins\Support;

use Illuminate\Support\Collection;
use Laravilt\Plugins\Contracts\Plugin;

class PluginManifest
{
    /**
     * @var Collection<string, Plugin>
     */
    protected Collection $plugins;

    /**
     * @param  Collection<string, Plugin>  $plugins
     */
    public function __construct(Collection $plugins)
    {
        $this->plugins = $plugins;
    }

    /**
     * Get manifest as array.
     */
    public function toArray(): array
    {
        return $this->plugins->map(function (Plugin $plugin) {
            return [
                'id' => $plugin->getId(),
                'name' => $plugin->getName(),
                'version' => $plugin->getVersion(),
                'description' => $plugin->getDescription(),
                'author' => $plugin->getAuthor(),
                'enabled' => $plugin->isEnabled(),
                'dependencies' => $plugin->getDependencies(),
            ];
        })->all();
    }

    /**
     * Get manifest as JSON.
     */
    public function toJson(): string
    {
        return json_encode($this->toArray(), JSON_PRETTY_PRINT);
    }
}
</file>

<file path="tests/TestCase.php">
<?php

namespace Laravilt\Plugins\Tests;

use Illuminate\Support\Facades\File;
use Laravilt\Plugins\PluginsServiceProvider;
use Orchestra\Testbench\TestCase as Orchestra;

class TestCase extends Orchestra
{
    protected function setUp(): void
    {
        parent::setUp();

        // Create packages directory
        $packagesPath = $this->app->basePath('packages/laravilt');
        if (! File::isDirectory($packagesPath)) {
            File::makeDirectory($packagesPath, 0755, true);
        }
    }

    protected function getPackageProviders($app): array
    {
        return [
            PluginsServiceProvider::class,
        ];
    }

    protected function getEnvironmentSetUp($app): void
    {
        $app['config']->set('database.default', 'testing');

        // Load config
        $pluginConfig = require __DIR__.'/../config/laravilt-plugins.php';
        $app['config']->set('laravilt-plugins', $pluginConfig);
        $app['config']->set('laravilt-plugins.defaults.author', $pluginConfig['defaults']['author'] ?? 'Fady Mondy');
        $app['config']->set('laravilt-plugins.defaults.email', $pluginConfig['defaults']['email'] ?? 'info@3x1.io');
        $app['config']->set('laravilt-plugins.defaults.license', $pluginConfig['defaults']['license'] ?? 'MIT');
    }

    /**
     * Resolve application base path implementation.
     */
    protected function resolveApplicationBasePath($app)
    {
        // Use the actual Laravel application base path (4 directories up from tests/)
        return realpath(__DIR__.'/../../../../') ?: $app->basePath();
    }

    protected function defineDatabaseMigrations(): void
    {
        //
    }

    protected function getTestPluginPath(): string
    {
        return $this->app->basePath('packages/laravilt/test-plugin');
    }

    protected function cleanupTestPlugin(): void
    {
        $path = $this->getTestPluginPath();
        if (File::exists($path)) {
            File::deleteDirectory($path);
        }
    }
}
</file>

<file path=".gitignore">
/.phpunit.cache
/bootstrap/ssr
/node_modules
/public/build
/public/hot
/public/storage
/storage/*.key
/storage/pail
/resources/js/actions
/resources/js/routes
/resources/js/wayfinder
/build
/vendor
.DS_Store
.env
.env.backup
.env.production
.phpactor.json
.phpunit.result.cache
Homestead.json
Homestead.yaml
npm-debug.log
yarn-error.log
/auth.json
/.fleet
/.idea
/.nova
/.vscode
/.zed
</file>

<file path="phpstan.neon">
parameters:
    level: 5
    paths:
        - src
    tmpDir: build/phpstan
    excludePaths:
        - src/Contracts/Plugin.php
        - src/BasePlugin.php
        - src/PluginProvider.php
</file>

<file path="config/laravilt-plugins.php">
<?php

return [
    /*
    |--------------------------------------------------------------------------
    | Plugin Discovery
    |--------------------------------------------------------------------------
    |
    | Enable or disable automatic plugin discovery. When enabled, Laravilt
    | will automatically discover and register plugins from installed packages.
    |
    */
    'discovery' => [
        'enabled' => env('LARAVILT_PLUGINS_DISCOVERY_ENABLED', true),
        'cache' => env('LARAVILT_PLUGINS_CACHE_ENABLED', true),
    ],

    /*
    |--------------------------------------------------------------------------
    | Plugin Paths
    |--------------------------------------------------------------------------
    |
    | Define custom paths where Laravilt should look for plugins.
    |
    */
    'paths' => [
        base_path('vendor'),
    ],

    /*
    |--------------------------------------------------------------------------
    | Default Plugin Configuration
    |--------------------------------------------------------------------------
    |
    | Default configuration for generated plugins.
    |
    */
    'defaults' => [
        'vendor' => env('LARAVILT_PLUGINS_DEFAULT_VENDOR', 'laravilt'),
        'author' => env('LARAVILT_PLUGINS_DEFAULT_AUTHOR', 'Fady Mondy'),
        'email' => env('LARAVILT_PLUGINS_DEFAULT_EMAIL', 'info@3x1.io'),
        'license' => env('LARAVILT_PLUGINS_DEFAULT_LICENSE', 'MIT'),
        'github_sponsor' => env('LARAVILT_PLUGINS_DEFAULT_GITHUB_SPONSOR', 'fadymondy'),
    ],

    /*
    |--------------------------------------------------------------------------
    | Plugin Features
    |--------------------------------------------------------------------------
    |
    | This array defines all available features for plugin generation.
    | Features are loaded in priority order (lower priority = earlier).
    |
    | You can add custom features by adding them to this array.
    |
    */

    'features' => [
        // Core Files
        \Laravilt\Plugins\Features\ComposerJsonFeature::class,
        \Laravilt\Plugins\Features\GitignoreFeature::class,
        \Laravilt\Plugins\Features\ServiceProviderFeature::class,
        \Laravilt\Plugins\Features\PluginClassFeature::class,
        \Laravilt\Plugins\Features\InstallCommandFeature::class,
        \Laravilt\Plugins\Features\ConfigFeature::class,

        // Structure Files
        \Laravilt\Plugins\Features\MigrationsFeature::class,
        \Laravilt\Plugins\Features\RoutesFeature::class,
        \Laravilt\Plugins\Features\ViewsFeature::class,
        \Laravilt\Plugins\Features\LanguageFeature::class,

        // Asset Files
        \Laravilt\Plugins\Features\CssFeature::class,
        \Laravilt\Plugins\Features\JsFeature::class,
        \Laravilt\Plugins\Features\ArtsFeature::class,

        // Testing Files
        \Laravilt\Plugins\Features\TestingFeature::class,
        \Laravilt\Plugins\Features\TestbenchFeature::class,
        \Laravilt\Plugins\Features\PintFeature::class,

        // Documentation Files
        \Laravilt\Plugins\Features\ReadmeFeature::class,
        \Laravilt\Plugins\Features\GitHubFeature::class,
        \Laravilt\Plugins\Features\DocumentationFeature::class,
    ],
];
</file>

<file path="src/Commands/MakePluginCommand.php">
<?php

namespace Laravilt\Plugins\Commands;

use Illuminate\Console\Command;
use Illuminate\Filesystem\Filesystem;
use Illuminate\Support\Str;
use Laravilt\Plugins\Services\PluginGenerator;

use function Laravel\Prompts\confirm;
use function Laravel\Prompts\multiselect;
use function Laravel\Prompts\text;

class MakePluginCommand extends Command
{
    protected $signature = 'laravilt:plugin
                            {name? : The name of the plugin}
                            {--vendor= : The vendor name}
                            {--path= : The base path where the plugin will be created}
                            {--no-plugin : Skip generating Filament plugin class (Laravel package only)}
                            {--no-assets : Skip asset scaffolding}';

    protected $description = 'Create a new Laravilt plugin package';

    public function __construct(
        protected Filesystem $files,
        protected PluginGenerator $generator
    ) {
        parent::__construct();
    }

    public function handle(): int
    {
        // Get plugin name
        $name = $this->getPluginName();
        if (! $name) {
            $this->error('Plugin name is required.');

            return self::FAILURE;
        }

        // Get vendor name
        $vendor = $this->getVendorName();

        // Prepare configuration
        $basePath = $this->option('path') ?: base_path('packages/'.Str::lower($vendor).'/'.Str::kebab($name));

        // Check if directory exists
        if ($this->files->exists($basePath)) {
            $this->error("Plugin directory already exists: {$basePath}");

            return self::FAILURE;
        }

        // Confirm creation
        if (! $this->confirmCreation($name, $basePath)) {
            $this->info('Plugin creation cancelled.');

            return self::SUCCESS;
        }

        $this->info("Creating plugin: {$name}...");

        // Gather configuration options
        $options = $this->gatherConfigurationOptions();

        // Generate the plugin using the service
        $config = $this->generator->prepareConfig(
            $name,
            $vendor,
            $basePath,
            $options['generate_plugin'],
            $options
        );

        $this->generator->createDirectoryStructure($basePath, $config);
        $this->generator->generateAllFiles($config);

        // Display success message
        $this->displaySuccessMessage($basePath);

        // Post-generation tasks
        if (! $this->option('no-interaction')) {
            $this->handlePostGeneration($basePath, $config);
        }

        return self::SUCCESS;
    }

    protected function getPluginName(): ?string
    {
        if ($this->argument('name')) {
            return $this->argument('name');
        }

        if ($this->option('no-interaction')) {
            return null;
        }

        return text(
            label: 'Plugin name',
            placeholder: 'E.g., BlogExtensions',
            required: true
        );
    }

    protected function getVendorName(): string
    {
        if ($this->option('vendor')) {
            return $this->option('vendor');
        }

        if ($this->option('no-interaction')) {
            return config('laravilt-plugins.defaults.vendor', 'laravilt');
        }

        return text(
            label: 'Vendor name',
            default: config('laravilt-plugins.defaults.vendor', 'laravilt'),
            required: true
        );
    }

    protected function gatherConfigurationOptions(): array
    {
        if ($this->option('no-interaction')) {
            return $this->getDefaultOptions();
        }

        $options = [];

        // Get plugin name for auto-filling
        $pluginName = $this->argument('name');
        $humanReadableName = trim(ucwords(str_replace(['-', '_'], ' ', Str::kebab($pluginName))));
        $defaultTitle = $humanReadableName;
        $defaultDescription = trim($humanReadableName.' plugin for Laravilt');

        $this->newLine();

        // Ask about features using multiselect
        $selectedFeatures = multiselect(
            label: 'Select the features you want to include:',
            options: [
                'plugin' => 'Laravilt plugin (for Filament panel integration)',
                'migrations' => 'Database migrations',
                'views' => 'Blade views',
                'web_routes' => 'Web routes',
                'api_routes' => 'API routes',
                'css' => 'CSS assets (Tailwind v4)',
                'js' => 'JavaScript assets (Vue.js plugin + Vite)',
                'arts' => 'Arts folder with cover photo (screenshot.jpg)',
                'languages' => 'Language files (i18n)',
                'github' => 'GitHub workflows and issue templates',
                'phpstan' => 'PHPStan for static analysis',
                'custom_composer' => 'Custom composer details (author, email, license)',
                'git_init' => 'Initialize Git repository',
                'composer_install' => 'Run composer install after generation',
                'run_tests' => 'Run tests after generation',
            ],
            default: ['plugin', 'github', 'phpstan', 'arts'],
            hint: 'Use space to select/deselect, enter to confirm'
        );

        // Parse selected features
        $options['generate_plugin'] = ! $this->option('no-plugin') && in_array('plugin', $selectedFeatures);
        $options['generate_migrations'] = in_array('migrations', $selectedFeatures);
        $options['generate_views'] = in_array('views', $selectedFeatures);
        $options['generate_web_routes'] = in_array('web_routes', $selectedFeatures);
        $options['generate_api_routes'] = in_array('api_routes', $selectedFeatures);
        $options['generate_css'] = in_array('css', $selectedFeatures);
        $options['generate_js'] = in_array('js', $selectedFeatures);
        $options['generate_arts'] = in_array('arts', $selectedFeatures);
        $options['generate_github_files'] = in_array('github', $selectedFeatures);
        $options['generate_phpstan'] = in_array('phpstan', $selectedFeatures);
        $options['git_init'] = in_array('git_init', $selectedFeatures);
        $options['composer_install'] = in_array('composer_install', $selectedFeatures);
        $options['run_tests'] = in_array('run_tests', $selectedFeatures);

        $this->newLine();

        // Ask for plugin details with auto-filled defaults
        $options['plugin_title'] = $defaultTitle;
        $options['plugin_description'] = $defaultDescription;

        // Ask about custom composer details (only if selected)
        if (in_array('custom_composer', $selectedFeatures)) {
            $options['plugin_description'] = text(
                label: 'Plugin description',
                default: $defaultDescription,
                placeholder: 'e.g., Manage users with advanced features',
                hint: 'Press Enter to use default or type your custom description'
            );

            $options['author'] = text(
                label: 'Author name',
                default: config('laravilt-plugins.defaults.author', 'Fady Mondy')
            );

            $options['author_email'] = text(
                label: 'Author email',
                default: config('laravilt-plugins.defaults.email', 'info@3x1.io'),
                required: true
            );

            $options['license'] = text(
                label: 'License',
                default: config('laravilt-plugins.defaults.license', 'MIT')
            );
        } else {
            $options['author'] = config('laravilt-plugins.defaults.author', 'Fady Mondy');
            $options['author_email'] = config('laravilt-plugins.defaults.email', 'info@3x1.io');
            $options['license'] = config('laravilt-plugins.defaults.license', 'MIT');
        }

        // Ask about Languages (only if selected)
        if (in_array('languages', $selectedFeatures)) {
            $languagesInput = text(
                label: 'Which languages do you need? (comma-separated)',
                default: 'en',
                hint: 'e.g., en,ar,fr'
            );
            $options['languages'] = array_map('trim', explode(',', $languagesInput));
        } else {
            $options['languages'] = ['en'];
        }

        // Ask about Sponsor (only if GitHub files are selected)
        if ($options['generate_github_files']) {
            $options['generate_sponsor'] = confirm(
                label: 'Do you have a GitHub Sponsor?',
                default: false
            );

            if ($options['generate_sponsor']) {
                $options['github_sponsor'] = text(
                    label: 'GitHub Sponsor username',
                    required: true
                );
            }
        }

        return $options;
    }

    protected function getDefaultOptions(): array
    {
        // Auto-fill title and description from plugin name
        $pluginName = $this->argument('name');
        $humanReadableName = trim(ucwords(str_replace(['-', '_'], ' ', Str::kebab($pluginName))));

        return [
            'plugin_title' => $humanReadableName,
            'plugin_description' => trim($humanReadableName.' plugin for Laravilt'),
            'author' => config('laravilt-plugins.defaults.author', 'Fady Mondy'),
            'author_email' => config('laravilt-plugins.defaults.email', 'info@3x1.io'),
            'license' => config('laravilt-plugins.defaults.license', 'MIT'),
            'generate_plugin' => ! $this->option('no-plugin'),
            'generate_migrations' => false,
            'generate_views' => false,
            'generate_web_routes' => false,
            'generate_api_routes' => false,
            'generate_css' => false,
            'generate_js' => false,
            'generate_arts' => true,
            'languages' => ['en'],
            'generate_github_files' => true,
            'generate_sponsor' => true,
            'github_sponsor' => config('laravilt-plugins.defaults.github_sponsor', 'fadymondy'),
            'generate_phpstan' => true,
            'git_init' => false,
            'composer_install' => false,
            'run_tests' => false,
        ];
    }

    protected function confirmCreation(string $name, string $basePath): bool
    {
        if ($this->option('no-interaction')) {
            return true;
        }

        return confirm(
            label: "Create plugin '".Str::studly($name)."' in {$basePath}?",
            default: true
        );
    }

    protected function displaySuccessMessage(string $basePath): void
    {
        $this->newLine();
        $this->info('✅ Plugin created successfully!');
        $this->newLine();

        $this->info('📦 Next steps:');
        $this->line('  1. Require the plugin in your composer.json');
        $this->line('  2. Run: composer install');
        $this->line('  3. Run: php artisan [plugin-name]:install');
        if (! $this->option('no-plugin')) {
            $this->line('  4. Register the plugin in your Filament panel provider');
        }
        $this->newLine();

        $this->info('📖 Plugin location: '.$basePath);
        $this->newLine();

        // Ask user to star the repository
        if (! $this->option('no-interaction')) {
            $this->askToStarRepository();
        }
    }

    /**
     * Ask the user to star the repository on GitHub.
     */
    protected function askToStarRepository(): void
    {
        $shouldStar = confirm(
            label: '⭐ Would you like to star this project on GitHub to support development?',
            default: true
        );

        if ($shouldStar) {
            $this->info('Opening GitHub in your browser...');
            $this->openUrl('https://github.com/laravilt/plugins');
            $this->newLine();
            $this->comment('Thank you for your support! 🙏');
        } else {
            $this->comment('No problem! You can always star it later at: https://github.com/laravilt/plugins');
        }
    }

    /**
     * Open a URL in the default browser.
     */
    protected function openUrl(string $url): void
    {
        $command = match (PHP_OS_FAMILY) {
            'Darwin' => "open '{$url}'",
            'Windows' => "start {$url}",
            'Linux' => "xdg-open '{$url}'",
            default => null,
        };

        if ($command) {
            exec($command);
        }
    }

    /**
     * Handle post-generation tasks.
     */
    protected function handlePostGeneration(string $basePath, array $config): void
    {
        $this->newLine();

        // Initialize Git repository (if selected in features)
        if ($config['git_init'] ?? false) {
            $this->initializeGitRepository($basePath);
        }

        // Register in main app's composer.json
        if (confirm(label: 'Register plugin in main app composer.json?', default: true)) {
            $this->registerInComposer($basePath, $config);
        }

        // Run composer install in plugin directory (if selected in features)
        if ($config['composer_install'] ?? false) {
            $this->info('Running composer install...');
            exec("cd {$basePath} && composer install", $output, $returnCode);

            if ($returnCode === 0) {
                $this->info('✅ Composer install completed successfully!');
            } else {
                $this->warn('⚠️  Composer install failed. Please run it manually.');
            }
        }

        // Run composer test (if selected in features)
        if ($config['run_tests'] ?? false) {
            $this->info('Running composer test...');
            exec("cd {$basePath} && composer test", $output, $returnCode);

            if ($returnCode === 0) {
                $this->info('✅ All tests passed!');
            } else {
                $this->warn('⚠️  Tests failed. Please check the errors above.');
            }
        }
    }

    /**
     * Initialize Git repository in plugin directory.
     */
    protected function initializeGitRepository(string $basePath): void
    {
        $this->info('Initializing Git repository...');

        // Initialize git
        exec("cd {$basePath} && git init", $output, $returnCode);

        if ($returnCode !== 0) {
            $this->warn('⚠️  Failed to initialize Git repository.');

            return;
        }

        $this->info('✅ Git repository initialized!');

        // Ask to create initial commit
        if (confirm(label: 'Create initial commit?', default: true)) {
            exec("cd {$basePath} && git add .", $output, $returnCode);
            exec("cd {$basePath} && git commit -m 'Initial commit: Plugin scaffolding'", $output, $returnCode);

            if ($returnCode === 0) {
                $this->info('✅ Initial commit created!');
                $this->comment('   Commit message: "Initial commit: Plugin scaffolding"');
            } else {
                $this->warn('⚠️  Failed to create initial commit.');
            }
        }

        // Ask to add remote repository
        if (confirm(label: 'Add remote repository?', default: false)) {
            $remoteUrl = text(
                label: 'Remote repository URL',
                placeholder: 'e.g., git@github.com:username/repo.git',
                required: true
            );

            exec("cd {$basePath} && git remote add origin {$remoteUrl}", $output, $returnCode);

            if ($returnCode === 0) {
                $this->info('✅ Remote repository added as origin!');
                $this->comment("   Remote URL: {$remoteUrl}");

                // Ask to push
                if (confirm(label: 'Push to remote repository?', default: false)) {
                    $branch = text(
                        label: 'Branch name',
                        default: 'master'
                    );

                    exec("cd {$basePath} && git branch -M {$branch} && git push -u origin {$branch}", $output, $returnCode);

                    if ($returnCode === 0) {
                        $this->info("✅ Pushed to {$branch} branch!");
                    } else {
                        $this->warn('⚠️  Failed to push to remote repository.');
                        $this->comment("   You can push manually with: git push -u origin {$branch}");
                    }
                }
            } else {
                $this->warn('⚠️  Failed to add remote repository.');
            }
        }
    }

    /**
     * Register the plugin in the main app's composer.json.
     */
    protected function registerInComposer(string $pluginPath, array $config): void
    {
        $appComposerPath = base_path('composer.json');

        if (! file_exists($appComposerPath)) {
            $this->warn('Could not find composer.json in main app');

            return;
        }

        $composerJson = json_decode(file_get_contents($appComposerPath), true);

        // Add to repositories
        $relativePath = str_replace(base_path().'/', '', $pluginPath);
        $composerJson['repositories'][] = [
            'type' => 'path',
            'url' => $relativePath,
        ];

        // Add to require
        $packageName = $config['vendor_lower'].'/'.$config['kebab_name'];
        $composerJson['require'][$packageName] = '@dev';

        file_put_contents(
            $appComposerPath,
            json_encode($composerJson, JSON_PRETTY_PRINT | JSON_UNESCAPED_SLASHES)
        );

        $this->info("✅ Plugin registered in composer.json as: {$packageName}");
        $this->comment('   Run: composer update to install the plugin');
    }
}
</file>

<file path="src/PluginsServiceProvider.php">
<?php

namespace Laravilt\Plugins;

use Illuminate\Support\ServiceProvider;
use Laravilt\Plugins\Contracts\PluginManager as PluginManagerContract;
use Laravilt\Plugins\Services\Generation\StubProcessor;
use Laravilt\Plugins\Services\PluginFeatureFactory;
use Laravilt\Plugins\Support\PluginManager;

class PluginsServiceProvider extends ServiceProvider
{
    /**
     * Register services.
     */
    public function register(): void
    {
        $this->mergeConfigFrom(
            __DIR__.'/../config/laravilt-plugins.php',
            'laravilt-plugins'
        );

        $this->app->singleton(PluginManagerContract::class, function ($app) {
            return new PluginManager($app);
        });

        $this->app->alias(PluginManagerContract::class, 'laravilt.plugins');

        // Register PluginFeatureFactory with features from config
        $this->app->singleton(PluginFeatureFactory::class, function ($app) {
            $factory = new PluginFeatureFactory;
            $stubProcessor = $app->make(StubProcessor::class);

            // Load features from config
            $featureClasses = config('laravilt-plugins.features', []);

            foreach ($featureClasses as $featureClass) {
                $feature = new $featureClass($stubProcessor);
                $factory->register($feature);
            }

            return $factory;
        });
    }

    /**
     * Bootstrap services.
     */
    public function boot(): void
    {
        if ($this->app->runningInConsole()) {
            $this->commands([
                Commands\MakePluginCommand::class,
                Commands\MakeComponentCommand::class,
                Commands\InstallMcpServerCommand::class,
            ]);

            $this->publishes([
                __DIR__.'/../config/laravilt-plugins.php' => config_path('laravilt-plugins.php'),
            ], 'laravilt-plugins-config');
        }

        // Auto-discover and register plugins
        $this->discoverPlugins();
    }

    /**
     * Discover and register plugins.
     */
    protected function discoverPlugins(): void
    {
        $manager = $this->app->make(PluginManagerContract::class);

        $manager->discover();
        $manager->bootAll();
    }
}
</file>

<file path="tests/Feature/McpServerTest.php">
<?php

use Laravilt\Plugins\Mcp\LaraviltPluginsServer;
use Laravilt\Plugins\Mcp\Tools\GenerateComponentTool;
use Laravilt\Plugins\Mcp\Tools\GeneratePluginTool;
use Laravilt\Plugins\Mcp\Tools\ListComponentTypesTool;
use Laravilt\Plugins\Mcp\Tools\ListPluginsTool;
use Laravilt\Plugins\Mcp\Tools\PluginInfoTool;
use Laravilt\Plugins\Mcp\Tools\PluginStructureTool;
use Laravilt\Plugins\Mcp\Tools\SearchDocsTool;

test('mcp server extends laravel mcp server', function () {
    expect(is_subclass_of(LaraviltPluginsServer::class, \Laravel\Mcp\Server::class))
        ->toBeTrue();
});

test('mcp server has correct name and version', function () {
    $reflection = new ReflectionClass(LaraviltPluginsServer::class);
    $name = $reflection->getProperty('name')->getDefaultValue();
    $version = $reflection->getProperty('version')->getDefaultValue();

    expect($name)->toBe('Laravilt Plugins');
    expect($version)->toBe('1.0.0');
});

test('mcp server has all 7 tools registered', function () {
    $reflection = new ReflectionClass(LaraviltPluginsServer::class);
    $tools = $reflection->getProperty('tools')->getDefaultValue();

    expect($tools)->toHaveCount(7);
    expect($tools)->toContain(ListPluginsTool::class);
    expect($tools)->toContain(PluginInfoTool::class);
    expect($tools)->toContain(GeneratePluginTool::class);
    expect($tools)->toContain(GenerateComponentTool::class);
    expect($tools)->toContain(ListComponentTypesTool::class);
    expect($tools)->toContain(PluginStructureTool::class);
    expect($tools)->toContain(SearchDocsTool::class);
});

test('all tool classes exist and extend tool base class', function () {
    $tools = [
        ListPluginsTool::class,
        ListComponentTypesTool::class,
        PluginInfoTool::class,
        PluginStructureTool::class,
        GenerateComponentTool::class,
        GeneratePluginTool::class,
        SearchDocsTool::class,
    ];

    foreach ($tools as $tool) {
        expect(class_exists($tool))->toBeTrue("Tool class {$tool} should exist");
        expect(is_subclass_of($tool, \Laravel\Mcp\Server\Tool::class))
            ->toBeTrue("Tool {$tool} should extend Laravel MCP Tool class");
    }
});

test('list component types tool has correct description', function () {
    $reflection = new ReflectionClass(ListComponentTypesTool::class);
    $description = $reflection->getProperty('description')->getDefaultValue();

    expect($description)->toContain('available component types');
});

test('all tools have handle method', function () {
    $tools = [
        ListPluginsTool::class,
        ListComponentTypesTool::class,
        PluginInfoTool::class,
        PluginStructureTool::class,
        GenerateComponentTool::class,
        GeneratePluginTool::class,
        SearchDocsTool::class,
    ];

    foreach ($tools as $toolClass) {
        $reflection = new ReflectionClass($toolClass);
        expect($reflection->hasMethod('handle'))
            ->toBeTrue("Tool {$toolClass} should have handle method");
    }
});

test('all tools have description property', function () {
    $tools = [
        ListPluginsTool::class,
        ListComponentTypesTool::class,
        PluginInfoTool::class,
        PluginStructureTool::class,
        GenerateComponentTool::class,
        GeneratePluginTool::class,
        SearchDocsTool::class,
    ];

    foreach ($tools as $toolClass) {
        $reflection = new ReflectionClass($toolClass);
        expect($reflection->hasProperty('description'))
            ->toBeTrue("Tool {$toolClass} should have description property");

        $description = $reflection->getProperty('description')->getDefaultValue();
        expect($description)->not->toBeEmpty("Tool {$toolClass} description should not be empty");
    }
});

test('mcp server has instructions for llm', function () {
    $reflection = new ReflectionClass(LaraviltPluginsServer::class);
    $instructions = $reflection->getProperty('instructions')->getDefaultValue();

    expect($instructions)->toContain('plugin management');
    expect($instructions)->toContain('packages/laravilt');
});
</file>

<file path=".github/workflows/fix-php-code-styling.yml">
name: Fix PHP Code Styling

on: [push]

jobs:
  php-code-styling:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v5
        with:
          ref: ${{ github.head_ref }}

      - name: Fix PHP code style issues
        uses: aglipanci/laravel-pint-action@2.6
        with:
          preset: laravel

      - name: Commit changes
        uses: stefanzweifel/git-auto-commit-action@v7
        with:
          commit_message: Fix styling
</file>

<file path="src/Stubs/composer.json.stub">
{
    "name": "{{ vendor }}/{{ package }}",
    "description": "{{ description }}",
    "version": "1.0.0",
    "type": "library",
    "license": "{{ license }}",
    "keywords": [
        "laravel",
        "laravilt",
        "plugin"
    ],
    "authors": [
        {
            "name": "{{ author }}",
            "email": "{{ email }}"
        }
    ],
    "require": {
        "php": "^8.3|^8.4",
        "spatie/laravel-package-tools": "^1.14"
    },
    "require-dev": {
        "larastan/larastan": "^2.9||^3.0",
        "laravel/pint": "^1.14",
        "nunomaduro/collision": "^8.1.1||^7.10.0",
        "orchestra/testbench": "^10.0",
        "pestphp/pest": "^3.0",
        "pestphp/pest-plugin-arch": "^3.0",
        "pestphp/pest-plugin-laravel": "^3.0",
        "pestphp/pest-plugin-livewire": "^3.0",
        "pestphp/pest-plugin-type-coverage": "^3.5",
        "phpstan/extension-installer": "^1.3||^2.0",
        "phpstan/phpstan-deprecation-rules": "^1.1||^2.0",
        "phpstan/phpstan-phpunit": "^1.3||^2.0"
    },
    "autoload": {
        "psr-4": {
            "{{ namespace }}\\": "src/"
        }
    },
    "autoload-dev": {
        "psr-4": {
            "{{ namespace }}\\Tests\\": "tests/",
            "{{ namespace }}\\Tests\\Database\\Factories\\": "tests/database/factories",
            "{{ namespace }}\\Tests\\Database\\Seeders\\": "tests/database/seeders"
        }
    },
    "scripts": {
        "testbench": "vendor/bin/testbench package:discover --ansi",
        "db": "vendor/bin/testbench package:create-sqlite-db && vendor/bin/testbench migrate",
        "analyse": "vendor/bin/phpstan analyse --memory-limit=512M",
        "test": "vendor/bin/pest",
        "test-coverage": "vendor/bin/pest --coverage",
        "format": "vendor/bin/pint"
    },
    "config": {
        "sort-packages": true,
        "allow-plugins": {
            "pestphp/pest-plugin": true,
            "phpstan/extension-installer": true
        }
    },
    "extra": {
        "laravel": {
            "providers": [
                "{{ namespace }}\\{{ service_provider }}"
            ]
        }
    },
    "minimum-stability": "dev",
    "prefer-stable": true
}
</file>

<file path="README.md">
![Screenshot](https://raw.githubusercontent.com/laravilt/plugins/master/arts/cover.jpg)

# Laravilt Plugins

[![Latest Stable Version](https://poser.pugx.org/laravilt/plugins/version.svg)](https://packagist.org/packages/laravilt/plugins)
[![License](https://poser.pugx.org/laravilt/plugins/license.svg)](https://packagist.org/packages/laravilt/plugins)
[![Downloads](https://poser.pugx.org/laravilt/plugins/d/total.svg)](https://packagist.org/packages/laravilt/plugins)
[![Dependabot Updates](https://github.com/laravilt/plugins/actions/workflows/dependabot/dependabot-updates/badge.svg)](https://github.com/laravilt/plugins/actions/workflows/dependabot/dependabot-updates)
[![PHP Code Styling](https://github.com/laravilt/plugins/actions/workflows/fix-php-code-styling.yml/badge.svg)](https://github.com/laravilt/plugins/actions/workflows/fix-php-code-styling.yml)
[![Tests](https://github.com/laravilt/plugins/actions/workflows/tests.yml/badge.svg)](https://github.com/laravilt/plugins/actions/workflows/tests.yml)

Complete plugin system with generator, management, and FilamentPHP v4 compatibility for Laravilt.ipsum

## ✨ Features

### 🎨 Plugin Generation
- **Interactive CLI** - Laravel Prompts with smart defaults
- **Factory Pattern** - Extensible feature-based architecture
- **Priority System** - Ordered feature execution (0-100)
- **Stub Processing** - Template-based file generation
- **Auto-Discovery** - Automatic plugin registration

### 🧩 Component Generators
Generate 13 component types within plugins:
- **Migration** - Database migrations with timestamps
- **Model** - Eloquent models with proper namespacing
- **Controller** - HTTP controllers
- **Command** - Artisan commands
- **Job** - Queueable jobs
- **Event** - Event classes
- **Listener** - Event listeners
- **Notification** - Notifications with mail support
- **Seeder** - Database seeders
- **Factory** - Model factories
- **Test** - Feature/Unit tests
- **Lang** - Language files
- **Route** - Route files

### 🤖 MCP Server Integration
- **AI Agent Support** - Built-in MCP server for Claude, GPT, etc.
- **6 Tools Available** - list-plugins, plugin-info, generate-plugin, generate-component, list-component-types, plugin-structure
- **Natural Language** - Generate plugins through conversation
- **Auto-Discovery** - AI agents can explore plugin ecosystem

### 🎨 Professional Assets
- **Cover Images** - Auto-generated 1200x630px screenshots
- **Dark Theme** - Professional gradient backgrounds
- **Plugin Branding** - Cyan icon with Laravilt branding
- **Social Media Ready** - Optimized for GitHub/Twitter previews
- **README Integration** - Auto-embedded in documentation

### ⚙️ GitHub Integration
- **Workflows** - tests.yml, fix-php-code-styling.yml, dependabot-auto-merge.yml
- **Issue Templates** - Bug reports, feature requests (GitHub forms)
- **Dependabot** - Automated dependency updates
- **FUNDING.yml** - GitHub Sponsors support
- **CONTRIBUTING.md** - Contribution guidelines
- **SECURITY.md** - Security vulnerability reporting

### 📦 Complete Package Setup
- **Service Provider** - Auto-discovery compatible
- **Configuration** - Publishable config with env support
- **Composer** - PSR-4 autoloading, version constraints
- **Testing** - Pest, PHPStan, Pint, Testbench
- **Assets** - Vite, Tailwind v4, Vue.js plugin support
- **Documentation** - README, CHANGELOG, LICENSE, CODE_OF_CONDUCT

## 📋 Requirements

- PHP 8.3+
- Laravel 12+
- FilamentPHP v4+ (for plugins features)
- Composer 2+
- Node.js 18+ (for asset compilation)

## 🚀 Installation

```bash
composer require laravilt/plugins
```

The service provider is auto-discovered and will register automatically.

### Configuration

Publish the configuration file:

```bash
php artisan vendor:publish --tag=laravilt-plugins-config
```

Configure defaults in `config/laravilt-plugins.php`:

```php
return [
    'defaults' => [
        'vendor' => env('LARAVILT_PLUGINS_DEFAULT_VENDOR', 'laravilt'),
        'author' => env('LARAVILT_PLUGINS_DEFAULT_AUTHOR', 'Your Name'),
        'email' => env('LARAVILT_PLUGINS_DEFAULT_EMAIL', 'your@email.com'),
        'license' => env('LARAVILT_PLUGINS_DEFAULT_LICENSE', 'MIT'),
        'github_sponsor' => env('LARAVILT_PLUGINS_DEFAULT_GITHUB_SPONSOR', 'yourusername'),
    ],
];
```

### MCP Server Setup (for AI Agents)

Install the MCP server configuration:

```bash
php artisan laravilt:install-mcp
```

This command will:
- Publish `routes/ai.php` (if needed)
- Register the MCP server in your routes
- Update `.mcp.json` for AI clients

After installation, restart your AI agent to access the plugin management tools.

## 📖 Usage

### Generate a Plugin

Interactive mode (recommended):

```bash
php artisan laravilt:plugin MyPlugin
```

Non-interactive mode:

```bash
php artisan laravilt:plugin MyPlugin --no-interaction
```

The command will guide you through:
1. Plugin name and description
2. Feature selection (migrations, views, routes, assets, etc.)
3. Author details (optional)
4. GitHub sponsor (optional)
5. Language selection

### Generate Components

Use the unified component generator:

```bash
php artisan laravilt:make
```

Or specify directly:

```bash
# Generate a model
php artisan laravilt:make my-plugin model Post

# Generate a controller
php artisan laravilt:make my-plugin controller PostController

# Generate a migration
php artisan laravilt:make my-plugin migration CreatePostsTable

# Generate a command
php artisan laravilt:make my-plugin command ProcessPostsCommand

# Generate a job
php artisan laravilt:make my-plugin job ProcessPost

# Generate a test
php artisan laravilt:make my-plugin test PostTest
```

All 13 component types are supported with proper namespace detection and PSR-4 structure.

### Generated Plugin Structure

```
my-plugin/
├── .github/
│   ├── workflows/
│   │   ├── tests.yml
│   │   ├── fix-php-code-styling.yml
│   │   └── dependabot-auto-merge.yml
│   ├── ISSUE_TEMPLATE/
│   │   ├── bug.yml
│   │   └── config.yml
│   ├── CONTRIBUTING.md
│   ├── FUNDING.yml
│   ├── SECURITY.md
│   └── dependabot.yml
├── arts/
│   └── screenshot.jpg                    # Auto-generated cover image
├── config/
│   └── laravilt-my-plugin.php
├── database/
│   ├── factories/
│   ├── migrations/
│   └── seeders/
├── resources/
│   ├── css/
│   │   └── app.css                       # Tailwind v4
│   ├── js/
│   │   └── app.js                        # Vue.js plugin
│   ├── lang/
│   │   └── en/
│   └── views/
├── routes/
│   ├── api.php
│   └── web.php
├── src/
│   ├── Commands/
│   │   └── InstallMyPluginCommand.php
│   ├── Http/
│   │   └── Controllers/
│   ├── Models/
│   ├── MyPluginPlugin.php                # Main plugin class
│   └── MyPluginServiceProvider.php
├── tests/
│   ├── Feature/
│   │   └── DebugTest.php
│   ├── Pest.php
│   └── TestCase.php
├── CHANGELOG.md
├── CODE_OF_CONDUCT.md
├── LICENSE.md
├── README.md
├── composer.json
├── package.json                          # If JS selected
├── phpstan.neon
├── pint.json
├── testbench.yaml
└── vite.plugin.js                        # If JS selected
```

## 🏗️ Architecture

### Factory Pattern

The plugin system uses a Factory Pattern for extensible feature generation:

```
Features (Priority 0-100)
├── Core Files (0-20)
│   ├── ComposerJsonFeature (1)
│   ├── GitignoreFeature (2)
│   ├── ServiceProviderFeature (5)
│   ├── PluginClassFeature (10)
│   ├── InstallCommandFeature (12)
│   └── ConfigFeature (15)
├── Structure Files (21-40)
│   ├── MigrationsFeature (25)
│   ├── RoutesFeature (30)
│   ├── ViewsFeature (35)
│   └── LanguageFeature (40)
├── Asset Files (41-60)
│   ├── CssFeature (50)
│   ├── JsFeature (51)
│   └── ArtsFeature (55)
├── Testing Files (61-80)
│   ├── TestingFeature (70)
│   ├── TestbenchFeature (75)
│   └── PintFeature (76)
└── Documentation Files (81-100)
    ├── ReadmeFeature (85)
    ├── GitHubFeature (90)
    └── DocumentationFeature (95)
```

### Extending with Custom Features

Create a custom feature:

```php
<?php

namespace App\PluginFeatures;

use Laravilt\Plugins\Features\AbstractFeature;

class CustomFeature extends AbstractFeature
{
    public function getName(): string
    {
        return 'custom';
    }

    public function shouldGenerate(array $config): bool
    {
        return $config['generate_custom'] ?? false;
    }

    public function getPriority(): int
    {
        return 99; // Execute near the end
    }

    public function generate(array $config): void
    {
        // Your generation logic
        $this->processor->generateFile(
            $config['base_path'].'/custom/file.php',
            'custom/file',
            ['key' => 'value']
        );
    }
}
```

Register in config:

```php
'features' => [
    // ... existing features
    \App\PluginFeatures\CustomFeature::class,
],
```

## 🤖 MCP Server

### Available Tools

#### `list-plugins`
List all installed Laravilt plugins.

#### `plugin-info`
Get detailed information about a specific plugin.

**Arguments:**
- `plugin` (string): Plugin name in kebab-case

#### `generate-plugin`
Generate a new plugin with specified features.

**Arguments:**
- `name` (string): Plugin name in StudlyCase
- `description` (string, optional)
- `migrations` (bool, default: false)
- `views` (bool, default: false)
- `webRoutes` (bool, default: false)
- `apiRoutes` (bool, default: false)
- `css` (bool, default: false)
- `js` (bool, default: false)
- `arts` (bool, default: true)
- `github` (bool, default: true)
- `phpstan` (bool, default: true)

#### `generate-component`
Generate a component within a plugin.

**Arguments:**
- `plugin` (string): Plugin name in kebab-case
- `type` (string): Component type (migration, model, controller, etc.)
- `name` (string): Component name

#### `list-component-types`
List all available component types.

#### `plugin-structure`
Get the complete directory structure of a plugin.

**Arguments:**
- `plugin` (string): Plugin name in kebab-case

### AI Agent Examples

```
You: "List all my plugins"
AI: [calls list-plugins tool]

You: "Create a blog plugin with migrations and views"
AI: [calls generate-plugin with appropriate parameters]

You: "Generate a Post model in the blog plugin"
AI: [calls generate-component]
```

## 🧪 Testing

Run tests in the plugins package:

```bash
cd packages/laravilt/plugins
composer test
```

Run tests in a generated plugin:

```bash
cd packages/myvendor/my-plugin
composer test          # Run Pest tests
composer format        # Format code with Pint
composer analyse       # Run PHPStan analysis
```

## 📚 Documentation

Comprehensive documentation is available in the `docs/` directory:

- [Getting Started](docs/getting-started.md)
- [Architecture](docs/architecture.md)
- [Plugin Generation](docs/plugin-generation.md)
- [Component Generators](docs/component-generators.md)
- [Factory Pattern](docs/factory-pattern.md)
- [Features System](docs/features-system.md)
- [MCP Server](docs/mcp-server.md)
- [API Reference](docs/api-reference.md)

## 🤝 Contributing

Please see [CONTRIBUTING.md](.github/CONTRIBUTING.md) for details.

## 🔒 Security

If you discover any security-related issues, please email info@3x1.io instead of using the issue tracker.

## 📝 Changelog

Please see [CHANGELOG.md](CHANGELOG.md) for recent changes.

## 📄 License

The MIT License (MIT). Please see [License File](LICENSE.md) for more information.

## 👥 Credits

- [Fady Mondy](https://github.com/fadymondy)
- [All Contributors](../../contributors)

## 🌟 Sponsors

Support this project via [GitHub Sponsors](https://github.com/sponsors/fadymondy).
</file>

<file path=".github/workflows/tests.yml">
name: Tests

on:
  push:
    branches: [ "master", "main" ]
  pull_request:
    branches: [ "master", "main" ]

jobs:
  test:
    runs-on: ubuntu-latest
    strategy:
      fail-fast: true
      matrix:
        php: [8.3, 8.4]
        laravel: [12.*]
        dependency-version: [prefer-stable]

    name: PHP ${{ matrix.php }} - Laravel ${{ matrix.laravel }} - ${{ matrix.dependency-version }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Setup PHP
        uses: shivammathur/setup-php@v2
        with:
          php-version: ${{ matrix.php }}
          extensions: dom, curl, libxml, mbstring, zip, pcntl, pdo, sqlite, pdo_sqlite, bcmath, soap, intl, gd, exif, iconv
          coverage: none

      - name: Setup problem matchers
        run: |
          echo "::add-matcher::${{ runner.tool_cache }}/php.json"
          echo "::add-matcher::${{ runner.tool_cache }}/phpunit.json"

      - name: Install dependencies
        run: |
          composer require "laravel/framework:${{ matrix.laravel }}" --no-interaction --no-update
          composer update --${{ matrix.dependency-version }} --prefer-dist --no-interaction

      - name: Execute tests
        run: vendor/bin/pest
</file>

<file path="composer.json">
{
    "name": "laravilt/plugins",
    "description": "Complete plugin system with generator, management, and FilamentPHP compatibility for Laravilt",
    "type": "library",
    "version": "1.0.0",
    "keywords": [
        "laravilt",
        "laravel",
        "plugins"
    ],
    "license": "MIT",
    "authors": [
        {
            "name": "Fady Mondy",
            "email": "info@3x1.io"
        }
    ],
    "require": {
        "php": "^8.3|^8.4",
        "illuminate/support": "^12.0",
        "illuminate/console": "^12.0",
        "illuminate/filesystem": "^12.0",
        "spatie/laravel-package-tools": "^1.14",
        "laravel/boost": "^1.8"
    },
    "require-dev": {
        "larastan/larastan": "^2.9||^3.0",
        "laravel/pint": "^1.14",
        "nunomaduro/collision": "^8.1.1||^7.10.0",
        "orchestra/testbench": "^10.0",
        "pestphp/pest": "^3.0",
        "pestphp/pest-plugin-arch": "^3.0",
        "pestphp/pest-plugin-laravel": "^3.0",
        "pestphp/pest-plugin-type-coverage": "^3.5",
        "phpstan/extension-installer": "^1.3||^2.0",
        "phpstan/phpstan-deprecation-rules": "^1.1||^2.0",
        "phpstan/phpstan-phpunit": "^1.3||^2.0"
    },
    "scripts": {
        "test": "vendor/bin/pest",
        "test-coverage": "vendor/bin/pest --coverage",
        "format": "vendor/bin/pint",
        "analyse": "vendor/bin/phpstan analyse"
    },
    "autoload": {
        "psr-4": {
            "Laravilt\\Plugins\\": "src/"
        }
    },
    "autoload-dev": {
        "psr-4": {
            "Laravilt\\Plugins\\Tests\\": "tests/"
        }
    },
    "extra": {
        "laravel": {
            "providers": [
                "Laravilt\\Plugins\\PluginsServiceProvider"
            ],
            "aliases": {
                "LaraviltPlugins": "Laravilt\\Plugins\\Facades\\LaraviltPlugins"
            }
        }
    },
    "prefer-stable": true,
    "config": {
        "allow-plugins": {
            "pestphp/pest-plugin": true,
            "phpstan/extension-installer": true
        }
    }
}
</file>

</files>
